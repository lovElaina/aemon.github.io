<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GET与POST的区别</title>
    <link href="/2022/05/03/GET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/03/GET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h3><ul><li>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li></ul><hr><h3 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h3><p>  HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p><p>  <strong>那么区别到底是什么呢？</strong></p><ul><li><strong>GET产生一个TCP数据包；POST产生两个TCP数据包。</strong></li><li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li><li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li><li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li><li>从<strong>幂等性</strong>的角度，<code>GET</code>是<strong>幂等</strong>的，而<code>POST</code>不是。(<code>幂等</code>表示执行相同的操作，结果也是相同的)</li></ul><p>  为什么GET产生一个TCP数据包；POST产生两个TCP数据包呢</p><p>  对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>  而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>  也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>  因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li>GET与POST都有自己的语义，不能随便混用。</li><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li><li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。  </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JIT-使用JAVA实现一个简单的Git</title>
    <link href="/2022/04/12/JIT-%E4%BD%BF%E7%94%A8JAVA%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Git/"/>
    <url>/2022/04/12/JIT-%E4%BD%BF%E7%94%A8JAVA%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Git/</url>
    
    <content type="html"><![CDATA[<h3 id="JIT-使用JAVA实现一个简单的Git"><a href="#JIT-使用JAVA实现一个简单的Git" class="headerlink" title="JIT-使用JAVA实现一个简单的Git"></a>JIT-使用JAVA实现一个简单的Git</h3><p>        参考git实现原理，我用Java实现了一个版本控制系统，并将它命名为jit。它可以看作是git的简化版本，与git相比，保留了核心的功能集，类似于git的最初发布版本，目前暂未实现git pull以及git push等需要网络连接的功能。项目已上传至github上，项目地址是：<a href="https://github.com/lovElaina/jit%E3%80%82">https://github.com/lovElaina/jit。</a><br>        项目遵循统一的编程风格以及注释风格，参考git实现原理和文件结构，使用key-value object实现blob，tree，commit的核心存储结构，实现了init，branch，checkout，add，rm，commit等基本功能，除此之外也实现了reset、log、restore、load等其他功能，使整个项目更完善，初步具备可用性。<br>        实现了两种运行方式，分别为：以命令行窗口模式运行，和以图形界面形式运行，对应两个入口函数，以满足不同使用习惯的用户需求。同时还提供了完备的帮助指令，让用户在键入错误的情况下能得到充足而有可行性的提示信息。<br>        项目依赖的Java版本为JDK1.8，使用intellij idea作为开发环境。由于属于轻量级应用，项目规模较小，故没有采用Gradle等构建工具，也没有使用第三方库（图形化界面使用swing框架，属于java内置的窗口工具包），最终的成品经idea打包后，使用exe4j从jar转为exe可执行文件，支持运行windows xp及以上版本的操作系统中。</p><h2 id="项目原理"><a href="#项目原理" class="headerlink" title="项目原理"></a>项目原理</h2><p>        从本质上来说，Jit是一组文件操作过程的集合。其底层操作为：文件及文件夹的创建、读取、写入、删除，各种复杂的上层操作，例如add、commit、checkout等，都是由这四类底层操作加上合适的数据结构和文件系统所实现。Jit可以在创建复杂的项目时，或在项目上与其他人协作时为我们提供帮助。我们能够使用Jit commit定期保存项目的版本。如果在以后的某个时间点不小心弄乱了代码，则可以使用git checkout将代码恢复到以前提交的版本，并且不会丢失此后所做的任何更改。<br>        Jit是一个内容寻址的简单文件系统，这意味着Jit 的核心部分是一个简单的键值对（key-value）存储库。 我们可以向Jit仓库中添加任意类型的内容。<br>        Jit和Git类似，都区分了几种不同类型的对象。分别是Blob（本质上是文件的内容），Tree（对 blob 和其他tree即子目录的引用，每个tree维护一张存放Blob和Tree条目的表），commits（日志消息、其他元数据如提交日期、作者、对树的引用和对父提交的引用等的引用）。<br>        每个对象（每个 blob 、每个tree和每个commit）都有一个唯一的40位16进制数，即哈希后得到的id，作为对对象的引用，与典型的实现不同，具有完全相同内容的两个对象在所有系统上将具有相同的 id。比如就 Blob 而言，“相同的内容”意味着相同的文件内容。</p><p><img src="/img/java1.png" alt="Blob、Tree、Commit对象的内部结构"><br>        Git 和 Jit 都以相同的方式完成哈希操作：通过使用称为 SHA-1的加密哈希函数完成，它为数据存储在.Jit 目录中提供了一个方便的文件名。还提供了一种方便的方法来比较两个文件（blob）以查看它们是否具有相同的内容：如果它们的 SHA-1 相同，我们就可以假设文件相同。<br>        基于上述讨论，我们可以向Jit仓库中添加任意类型的内容。如果添加的是文件，则它会被压缩存储在一个保存在object目录下的文件中，而文件名是经过对文件内容经过哈希运算得到的40位16进制数（这点与Git存在差别，在Git中，哈希运算得到的40位中，前两位作为文件夹名存放在objcet目录下，后38位作为文件名存放在其对应的前两位文件夹下，可以看到这里采用了简化的处理方式）。不仅如此，还会添加这个文件的信息到暂存区（Index）中。<br>如果添加的是文件夹，则Jit会递归遍历该文件夹中的所有文件，并类似地，把他们全部作为blob对象存储，注意：只有在commit时，才会从Index文件中生成树。<br>        另外，branch部分也是重要的组成部分，Jit的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。<br>        由于Jit的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都非常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符）。<br>        这也是Git中的默认实现，与以往其他大多数版本控制系统不同，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在Jit以及Git中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找共同祖先也是同样的简单和高效。 这些高效的特性使得我们鼓励用户频繁地创建和使用分支。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>        我对项目进行了部分重构，使之更符合面向对象方法学要求。<br>        Jit项目有7个包，每个包都是特定的一类操作的集合，这些包分别是：branch（存放与分支有关的数据源类）、core（存放主要命令对应的操作类，例如JitInit、JitAdd、JitCommit等）、Diff（存放差异算法的实现类）、gitobject（存放与Object对象有关的数据源类，例如GitObject抽象类、Blob、Tree、Commit类等）repo（存放repository类，之所以把它单独拿出来放在一个包中，是因为它和branch一样，都有着独特的操作和含义，与其他任何包所覆盖的范围都不同），tmp（存放与Index有关的类、commit过程中产生的虚拟节点，因为它们都是临时性质的，所以命名位tmp），utils（包含全局且常用的操作类，例如FileCreation类定义了文件创建方法、FileDeletion类定义了文件删除方法、SHA1类定义了哈希方法，Utils类定义了读取、设置工作路径和文本信息的方法。<br><img src="/img/java2.png"><br><img src="/img/java3.png"><br>        上两张图包含了Jit项目中的所有类，还有每个类对应的属性和方法。</p><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>        这一节我会介绍Jit项目的各个类中包含的主要属性方法，并对各类与整体之间的关系及作用分别加以说明。</p><h1 id="Client类"><a href="#Client类" class="headerlink" title="Client类"></a>Client类</h1><p>        这是Jit命令行程序的入口类，从main函数进入，main函数循环取得键入指令，并将指令字符串通过str.split转为字符串数组，对数组中的值进行判断，例如如果arr[1]的值等于”init”，就执行jit init。类中的各方法分别对应相关的指令，当输入”jit init” 时，会执行jit Init方法，输入”jit add xxx”时，会执行jit add方法将xxx序列化为blob文件并将这条记录添加到index文件，输入”jit commit”时，会执行jit commit方法，输入”jit remove”时，会执行jit remove方法，根据后缀参数，在index文件中移除file对应的文件记录，或强制删除files（既删除index中对应的记录），又删除本地工作区文件输入”jit log”时，会执行jit log方法，从当前HEAD指向的commit打印历史commit记录，输入”jit reset”时，根据后缀参数不同，或重置到最近一次提交，只重置暂存区，或同时重置工作区和暂存区的文件，输入”jit branch”时，根据后缀参数不同，执行分支创建、删除等相关操作，输入”jit checkout”时，执行分支切换操作，输入”jit restore”时，会会撤销文件的修改，使暂存区的文件恢复到工作区，即最近一次执行完jit add的状态（注意：没有放入暂存区的文件会消失）。<br><img src="/img/java4.png"><br>        上图是Client类中的所有方法列表。概括来说，它是根据输入字符串不同，寻找匹配的方法并执行，而每个匹配的方法中又对应了更详细的操作流程，例如JitInit类中的init方法，它首先更具传入的工作目录创建仓库对象，如果仓库已存在，则打印提示信息，否则建立使用仓库类中的createRepo方法创建本地仓库，可以看到这些操作类是链接输入输出和数据类的纽带，整个项目为MVC模型，操作类属于Controller，即控制器部分，而调用它的Client类中的各种方法，属于View，即视图层，其他分散在各个包中的类，（例如repo包中的Repository类、branch包中的Branch类、gitobject包中的Tree、Blob、Commit等类）属于Model，即数据模型层。<br><img src="/img/java5.png"><br>接下来我会对各个Controller层的类进行详细介绍（即位于core包中的以Jit开头的所有类）</p><h1 id="JitAdd类"><a href="#JitAdd类" class="headerlink" title="JitAdd类"></a>JitAdd类</h1><p>        功能上实现了两个部分，分别是添加文件对象到暂存区中，如果缓存区中有和待添加文件同名的记录，则按时间顺序更新（后加入的必然替换先前存在的），同时会创建一个blob对象，并使用compressWrite方法序列化到Object目录下的文件中。</p><p><img src="/img/java6.png"><br>        文件内容经过ZLibUtils的compress方法压缩，如下图所示：<br><img src="/img/java7.png"><br>        此外，如果jit add添加的是一个文件夹，则使用file类的listFiles列出文件夹中存在的所有文件，并分别递归调用add方法，直到文件夹中的所有文件全部被添加到Index中。</p><h1 id="JitCommit类"><a href="#JitCommit类" class="headerlink" title="JitCommit类"></a>JitCommit类</h1><p>        是执行commit的操作类，结构如下图所示。</p><p><img src="/img/java8.png"><br>        功能上分为三个部分，分别是：<br>        （1）创建commit对象并保存到repository，并且把commit的key写入branch文件<br><img src="/img/java9.png"><br>        （2）更新branch，把commit key信息写入refs/heads中<br><img src="/img/java10.png"><br>        （3）从现有的index文件中创建indexTree对象<br><img src="/img/java11.png"><br>    这里使用了TreeMap作为数据结构，存储的键值对分别为String型和ObjectNode型，其中ObjectNode是自定义的虚拟节点类，所以buildIndexTree方法是根据Index中存储的记录产生虚拟节点的过程，ArrayList&lt;String[]&gt; idxList = idxObject.getIndexs();定义一个类型为String数组的ArrayList，它接收之前创建的Index对象中的index属性，注意两者并不等同，如下图所示为index的类型。<br><img src="/img/java12.png"><br>    而getIndexs方法返回这个index，即它是一层封装，避免对象中的方法名被通过对象名.方法名的方式直接调用。<br>    得到存储Index记录的idexList后再循环遍历idxList，找到每个元素的path，即文件路径，这里使用Array.asList方法，逐级对路径进行拆分，并定义另外一个List类型的变量splitedPath存放，接下来遍历splitedPath，如果位于同一层级之下已经有指定的路径，则cur指向内层，否则在cur的当前层级下存放键值对，键为当前路径名，值为新创建的ObjectNode对象，如下图所示。<br><img src="/img/java13.png"><br>    bulidTree方法用当前的虚拟结点中的数据创建树对象，虽然代码比较简短，却是最重要的一步。Tree的构造方法在下一节会提到。<br><img src="/img/java14.png"></p><h1 id="JitBranch类"><a href="#JitBranch类" class="headerlink" title="JitBranch类"></a>JitBranch类</h1><p>        定义对于分支的一系列操作，类中包含如下方法：</p><p><img src="/img/java15.png"><br>    其中getBranch方法得到HEAD中存放的branch路径，例如：ref: refs/heads/master，substring(16)就是master，并返回由它得到的branch对象。<br><img src="/img/java16.png"><br>    branchExist方法判断分支名所对应的分支文件是否存在，若存在返回true<br><img src="/img/java17.png"><br>    branchAdd方法创建一个新的branch并且把这个branch文件添加到refs/heads文件夹<br><img src="/img/java18.png"><br>    而branch方法列出所有现存的分支名，如果在执行这个方法之前调用了deleteBranch方法删除了一个分支，则不显示被删除的分支名。<br><img src="/img/java19.png"><br>    注意：如果master分支还不存在，则会收到提示信息“master分支不存在，你应该至少先提交一次”，另外，从HEAD文件中读取的branch名和refs/heads中的branch文件名相同时，表示是当前分支，当前分支需要在分支名前面加上*号。<br>    createBranchWithMaster方法在master分支所指向的位置处创建一个新分支，同样地，如果master分支不存在，则会收到提示信息“master分支不存在，你应该至少先提交一次”。<br><img src="/img/java20.png"><br>    deleteBranch方法传入String类型的分支名，然后删除这个分支名对应的分支，其实质是删除项目当前目录.jit\refs\heads中的分支名对应的文件<br><img src="/img/java21.png"><br>    如上图所示，如果执行deleteBranch(test)，则会删除该文件。顺带一提，每个分支文件中保存着这个分支当前指向的commit Key，例如上图中的master分支内容如下<br><img src="/img/java22.png"><br>    注意：在删除分支之前，需要确保1、希望删除的分支名是现存的。2、删除的分支不是当前分支（否则程序不知道你现在应该指向哪个位置，程序不能随机指派一个分支以供切换，尤其是只有一个分支的时候，删除的一定是当前分支，这时指针指向为空，会产生严重错误。<br>    遵循上述讨论，删除分支的代码如上图所示。</p><h1 id="JitCheckout类"><a href="#JitCheckout类" class="headerlink" title="JitCheckout类"></a>JitCheckout类</h1><p>        用于实现切换分支的操作类，类结构如下图所示：</p><p><img src="/img/java23.png"><br>    其中path方法为存放各分支文件的heads文件夹路径，定义如下：<br>    static String path = Utils.getJitDir() + File.separator + “refs” + File.separator + “heads”;<br>    branExist方法确定位于refs/heads，且名为branchNames的分支文件是否存在<br><img src="/img/java24.png"><br>    checkOut方法切换到名为branchName的分支，它比changeHead方法多了一个条件判断<br><img src="/img/java25.png"><br>    由于checkout不仅切换分支，还会切换到分支所在的文件状态，例如分支master中有文件aa.txt、bb.txt,而分支hotfix中只有文件aa.txt，则从master分支切换到hotfix分支时，会删除bb.txt，这里涉及到一组操作：删除当前工作目录的所有文件，并通过传入的分支名切换到该分支，即改变HEAD文件中的分支名（HEAD文件相当于指针，指向最近操作的分支名）代码如下：<br><img src="/img/java26.png"><br>    然后由分支名获取到新分支的对象，再通过分支中保存的commitKey获取到commit对象，再由Commit类中的getTree方法获取到树对象，通过FileCreation中的recoverWorkTree方法恢复树对应的所有文件。<br><img src="/img/java27.png"><br>    最后，还要恢复Index文件中的记录到指定的branch中保存的状态，这个过程也分为两步，第一步删除当前Index文件中的所有记录，第二部把当前所有的工作区文件（此时已经切换到新分支名所对应的工作区了）的文件记录都添加到index中。<br><img src="/img/java28.png"></p><h1 id="JitLog类"><a href="#JitLog类" class="headerlink" title="JitLog类"></a>JitLog类</h1><p>        JitLog类只包含一个printLog方法，即打印输出当前branch所指向的commit记录，并向上追溯一直到父commit为空。</p><p><img src="/img/java29.png"><br>    由于频繁涉及字符串的拼接操作，所以使用stringBuilder类，因为和 String 类不同，StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象，所以既提高了效率，又节省了空间。首先通过Branch currentBranch = getBranch();方法得到当前的Branch对象，从branch中的getCommitKey方法中取得commit对象的key，然后由key构造commit对象，打印其对应的value值，然后由getparent方法得到它的父提交对象的commit key，如果不为null，则循环整个过程，打印输出的结果如下所示：<br><img src="/img/java30.png"><br>    打印顺序是从当前commit出发一直到最初（parent为null）的commit。</p><h1 id="JitReset类"><a href="#JitReset类" class="headerlink" title="JitReset类"></a>JitReset类</h1><p>        作用是重置到某次提交的状态，根据输入参数不同，可以选择只重置暂存区，或同时重置暂存区和工作区。<br>        重置到最近一次提交，只重置暂存区</p><p><img src="/img/java31.png"><br>    重置到特定的提交（commitKey），只重置暂存区<br><img src="/img/java32.png"><br>    重置到特定的提交（commitKey），工作区和暂存区的文件也同步重置<br><img src="/img/java33.png"></p><h1 id="JitRestore类"><a href="#JitRestore类" class="headerlink" title="JitRestore类"></a>JitRestore类</h1><p>        这是我额外加入的功能，它会撤销文件的修改，使暂存区的文件恢复到工作区，即最近一次执行完jit add的状态。</p><p><img src="/img/java34.png"><br>    它首先执行文件删除，把工作区的所有文件删除，保留.jit文件夹，然后从Index文件中获取数据到ArrayList中，恢复为工作区文件。</p><h1 id="JitRem类"><a href="#JitRem类" class="headerlink" title="JitRem类"></a>JitRem类</h1><p>        即JitRemove的功能，实现两种方法：在index文件中移除file对应的文件记录或强制删除files，既删除index中对应的记录，又删除本地工作区文件，代码如下所示：</p><p><img src="/img/java35.png"></p><h1 id="GitObject类"><a href="#GitObject类" class="headerlink" title="GitObject类"></a>GitObject类</h1><p>        从这里开始往后介绍的，都属于数据源类，GitObjcet我将它定义为抽象类，后面的Blob、Tree和Commit类，都继承自它。结构如下所示：</p><p><img src="/img/java36.png"><br>    先从属性看，所有的属性均为private类型，其中type用于标识object类型，例如blob、tree、commit等，num用于表示标识号，在Git中，10644表示Blob型，04000表示Tree型，虽然在Jit中没有特别的作用，但我这里希望和Git统一格式，所有没有去除。Key用于表示经过hash之后的40位16进制数，无论是Blob、Tree还是Commit，都有对应的key值，它可以作为一个GitObject对象的ID。Value表示存储在各对象文件中的值，例如Blob的value表示文件内容，Tree的value表示一个表，其中每个数据条目对应一个blob或key的属性摘要，Commit的value值为该Commit的信息摘要，如下图所示：<br><img src="/img/java37.png"><br>    同时我使用Get和Set方法，保持了数据的封装性，并规范了调用方式。<br><img src="/img/java38.png"><br>    此外在GitObject中，我还定义了compressWrite方法，它可以进行数据的压缩写入，即value经过ZlibUtils压缩之后，序列化到本地。<br><img src="/img/java39.png"></p><h1 id="Blob类"><a href="#Blob类" class="headerlink" title="Blob类"></a>Blob类</h1><p>        它是继承自GitObject。有三个构造函数，分别为空参数、传入File类型作为参数、传入String类型作为参数。结构图如下所示：</p><p><img src="/img/java40.png"><br>    空参数为默认的构造函数，使用super()，仅确定Type和Num的类型。<br><img src="/img/java41.png"><br>    它表示从文件中构造一个Blob对象，即把File的内容读取出来，设置为Blob对象的value值，同时设置Path为它所在的工作区路径。<br><img src="/img/java42.png"><br>    最后一个构造函数表示从Object文件夹下找到传入的key所对应的Blob文件，再由文件信息构建对象，它也是十分常用的方法。<br><img src="/img/java43.png"></p><h1 id="Tree类"><a href="#Tree类" class="headerlink" title="Tree类"></a>Tree类</h1><p>        它也是继承自GitObject类，是树对象对应的类。<br>        结构图如下所示：</p><p><img src="/img/java44.png"><br>    定义一个类型为ArrayList<GitObject>的属性，存储当前树对象维护的一个列表，每一个元素都为Blob或Tree类型。同时设置它的get和set方法，如下图所示。<br><img src="/img/java45.png"><br>    设置Tree类有三个构造方法，分别为传入空参数、TreeMap参数、Key参数。<br><img src="/img/java46.png"><br>    上文已经介绍过使用TreeMap定义的indexTree，它是commit时由Index中的数据产生的虚拟结点，在这里作为参数传入Tree中，生成Tree对象。<br><img src="/img/java47.png"><br>    这个构造函数传入的时key值，然后判断Object中的key值对应的文件是否存在，若存在就解压缩，设置value为解压缩之后的值，即原来的value值。然后调用同属于Tree类中的genTreeList方法，它的作用是从已存在的树对象中生成treeList：<br><img src="/img/java48.png"></p><h1 id="Commit类"><a href="#Commit类" class="headerlink" title="Commit类"></a>Commit类</h1><p>        它用于描述提交对象的属性信息和行为。也继承自GitObject类，所以除了GitObject中的属性和方法之外，它还有增加了一些属性和方法，如下图所示。</p><p><img src="/img/java49.png"><br>    属性sha_tree表示当前的commit所指向树的sha1值，sha_parent表示父提交对象的sha1值，author表示作者的姓名和提交时间，committer表示当前提交者的姓名，它与作者可能不同，message表示提交者自行输入的提交信息，每次提交输入的信息最好不重复。同时我也定义了这几个属性的getter和setter方法。接下来是构造函数，Commit类中定义了三个构造函数，分别是无参、接收commitKey作为参数、接收Tree、author、commiter、message等信息作为参数。<br>    下图为接收commitKey作为参数的构造函数，它从序列化后，存放在Object文件夹下的名为commitKey的文件中提取信息，并由这些信息生成commit对象。<br><img src="/img/java50.png"><br>    下图为接收Tree、author、commiter、message作为参数的构造函数，它从一个已经构建好的Tree对象中构建Commit对象，所以需要指定其它Commit对象所需要的各项属性。<br><img src="/img/java51.png"><br>    除此之外，还有genKey方法，用于得到这次提交生成的commit对象hash值。<br><img src="/img/java52.png"><br>    getLastCommit方法从HEAD文件中得到parent commit key<br><img src="/img/java53.png"></p><h1 id="Repository类"><a href="#Repository类" class="headerlink" title="Repository类"></a>Repository类</h1><div class="code-wrapper"><pre><code class="hljs">这个类主要负责生成.jit文件夹，即内部的文件结构，如下图所示：</code></pre></div><p><img src="/img/java54.png"><br>    Repository类中的createRepo方法通过文件创建类FileCreation中的createDirectory和createFile方法完成文件层级结构的构建。<br><img src="/img/java55.png"><br>    此外，还有utils包中的各个工具类、diff包中的Myers算法实现类，tmp包中的Index类等，限于篇幅关系在这里不做介绍，在代码中，我写了详细的注释，您可以通过阅读代码的方式了解这些类的结构和功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slice的内部实现</title>
    <link href="/2022/03/01/Slice%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/01/Slice%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="Slice的内部实现"><a href="#Slice的内部实现" class="headerlink" title="Slice的内部实现"></a>Slice的内部实现</h3><p>        这个方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.slice = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">start,end</span>)</span>&#123; <br>      <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <br>      start = start || <span class="hljs-number">0</span>; <br>      end = end || <span class="hljs-built_in">this</span>.length; <span class="hljs-comment">//this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键 </span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++)&#123; <br>           result.push(<span class="hljs-built_in">this</span>[i]); <br>      &#125; <br>      <span class="hljs-keyword">return</span> result; <br> &#125;<br></code></pre></td></tr></table></figure><p><strong>附：slice与splice与split</strong></p><p>1、splice(会修改原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">var</span> bbb = arr.splice(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-built_in">console</span>.log(arr) <br><span class="hljs-comment">//[ 1, 2, &#x27;hello&#x27;, &#x27;wo&#x27;, 5 ]</span><br><span class="hljs-built_in">console</span>.log(bbb)<br><span class="hljs-comment">//[ 3, 4 ]</span><br></code></pre></td></tr></table></figure><p>2、slice(不会修改原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">var</span> bbb = arr.slice(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">console</span>.log(bbb)<br><span class="hljs-comment">//[3, 4]</span><br><br><span class="hljs-keyword">var</span> ccc = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-keyword">var</span> ddd = ccc.slice(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br><span class="hljs-built_in">console</span>.log(ddd)<br><span class="hljs-comment">//lo</span><br></code></pre></td></tr></table></figure><p>3、split</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;How are you doing today?&quot;</span>;<br><span class="hljs-keyword">var</span> n=str.split(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-built_in">console</span>.log(n);<br><span class="hljs-comment">//[ &#x27;How&#x27;, &#x27;are&#x27;, &#x27;you&#x27;, &#x27;doing&#x27;, &#x27;today?&#x27; ]</span><br><span class="hljs-keyword">var</span> hh = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-keyword">var</span> ss = hh.split(<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-built_in">console</span>.log(ss)<br><span class="hljs-comment">//[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;]&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序 GlobalData</title>
    <link href="/2022/02/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20GlobalData/"/>
    <url>/2022/02/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20GlobalData/</url>
    
    <content type="html"><![CDATA[<h3 id="微信小程序-GlobalData"><a href="#微信小程序-GlobalData" class="headerlink" title="微信小程序 GlobalData"></a>微信小程序 GlobalData</h3><p>        微信小程序在JavaScript文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。如果希望在各个页面之间共同使用某些信息，并且可以对共享数据进行修改设置，以便于其他页面根据数据变化进行对应的调整，最好使用全局数据globalData。</p><p>        globalData在app.js文件中app()全局应用实例中：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br>App(&#123;<br>  <span class="hljs-attr">globalData</span>: <span class="hljs-number">1</span> <br>&#125;)<br></code></pre></td></tr></table></figure><p>　　由于它具有共享属性，对于它的设置和修改，需要分两方面来说明。</p><p>　　第一，在app.js文件中，怎样设置和修改。设置其实跟在其他js文件中设置data值是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//app.js</span><br>App(&#123;<br>    <span class="hljs-attr">globalData</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>     &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>　　你可以根据自己的需求，设置任何数据。在app.js中读取globalData，使用this就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//app.js</span><br>App(&#123;<br>    <span class="hljs-attr">globalData</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;,<br>    <span class="hljs-attr">onLoad</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.globalData.name);<br>    &#125;<br>&#125;) <br></code></pre></td></tr></table></figure><p>　　同样的，如果我们需要在app.js中修改globalData，只需要给对应的变量重新赋值就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//app.js</span><br>App(&#123;<br>    <span class="hljs-attr">globalData</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> <br>     &#125;,<br>    <span class="hljs-attr">onLoad</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <br>        <span class="hljs-built_in">this</span>.globalData.name = <span class="hljs-string">&#x27;李四&#x27;</span><br>     &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>　　第二，在其他页面读取以及修改globalData。不论是读取还是修改，首先需要在应用的页面js文件中，引用app()实例，所以在js文件中，第一句要写上这句:var app = getApp();</p><p>　　然后，我们来看怎么获取globalData：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//index.js</span><br><span class="hljs-keyword">var</span> app = getApp();<br>Page(&#123;<br>    <span class="hljs-attr">onLoad</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(app.globalData.name);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>　　下面看在其他页面怎么设置或者修改globalData。这里需要用到全局函数 getApp()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//index.js</span><br><span class="hljs-keyword">var</span> app = getApp();<br>Page(&#123;<br>    <span class="hljs-attr">onLoad</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        getApp().globalData.name = <span class="hljs-string">&quot;zyc&quot;</span>;  <br>　　　　 getApp().globalData.favorite = <span class="hljs-string">&quot;编程&quot;</span>;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>　　这样，就可以在index.js文件中，重新设置或者修改globalData的数据了。上面的例子，我们修改了globalData的name值，并且添加了一个编程的爱好的属性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序用户信息接口调整的应对方法</title>
    <link href="/2022/02/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3%E8%B0%83%E6%95%B4%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3%E8%B0%83%E6%95%B4%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="小程序用户信息接口调整的应对方法"><a href="#小程序用户信息接口调整的应对方法" class="headerlink" title="小程序用户信息接口调整的应对方法"></a>小程序用户信息接口调整的应对方法</h3><blockquote><p>为进一步规范开发者调用用户信息相关接口或功能，提升用户体验，平台将对部分用户信息相关功能及接口进行调整，具体如下：</p><p> <open-data>组件功能调整</p><p>开发者在未获取用户明示同意的情况下通过 <open-data>组件 在小程序中展示用户个人信息，用户容易误以为自己的个人信息在未授权的情况下，被小程序获取。平台计划<strong>从2022年2月21日24时起回收通过<open-data>展示个人信息的能力</strong>，若小程序需收集用户昵称头像等信息，可以通过 头像昵称填写功能功能进行收集。具体回收方式为：</p><ol><li>头像展示为灰色头像</li><li>用户昵称展示“微信用户”</li><li>用户性别、地区、语言展示为为空（“”）</li></ol><p>小程序通过<open-data>展示群名称能力保留，平台会针对小程序生命周期内首次调用该组件展示群名称向用户提示：“群名称仅你可见，小程序无法获取。”</p></blockquote><p><img src="/img/tx.gif" alt="腾讯 (ˉ▽ˉ；)..."></p><p>直接上代码吧</p><p>调整前：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_logo&quot;</span> <span class="hljs-attr">wx:if</span>=<span class="hljs-string">&quot;&#123;&#123;openid!=&#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_logo_pho&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">open-data</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;userAvatarUrl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">open-data</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_logo_text&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">open-data</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;userNickName&quot;</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh_CN&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;user_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">open-data</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_logo&quot;</span> <span class="hljs-attr">wx:if</span>=<span class="hljs-string">&quot;&#123;&#123;openid==&#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top_title&quot;</span>&gt;</span>you have not log<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;getopenid&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span>log<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>调整后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_logo&quot;</span> <span class="hljs-attr">wx:if</span>=<span class="hljs-string">&quot;&#123;&#123;openid!=&#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_logo_pho&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;open-data type=&quot;userAvatarUrl&quot;&gt;&lt;/open-data&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;userinfo-avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&#123;&#123;userinfo.avatarUrl&#125;&#125;&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;cover&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_logo_text&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;open-data type=&quot;userNickName&quot; lang=&quot;zh_CN&quot; class=&quot;user_name&quot;&gt;&lt;/open-data&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;user_name&quot;</span>&gt;</span>&#123;&#123;userinfo.nickName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_logo&quot;</span> <span class="hljs-attr">wx:if</span>=<span class="hljs-string">&quot;&#123;&#123;openid==&#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top_title&quot;</span>&gt;</span>you have not log<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;getopenid&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span>log<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>export 和 export default 的区别</title>
    <link href="/2022/02/22/export%20%E5%92%8C%20export%20default%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/02/22/export%20%E5%92%8C%20export%20default%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="export-和-export-default-的区别"><a href="#export-和-export-default-的区别" class="headerlink" title="export 和 export default 的区别"></a>export 和 export default 的区别</h3><p><strong><code>export</code>命令用于规定模块的对外接口。</strong></p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br></code></pre></td></tr></table></figure><p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p><p><code>export</code>的写法，除了像上面这样，还有另外一种。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><span class="hljs-keyword">export</span> &#123;firstName, lastName, year&#125;;<br></code></pre></td></tr></table></figure><p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p><p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x * y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码对外输出一个函数<code>multiply</code>。</p><p><code>export</code>命令对外输出了指定名字的变量（变量也可以是函数或类）。</p><p>与export default命令的区别：<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; lastName <span class="hljs-keyword">as</span> surname &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong><code>export default</code>命令，为模块指定默认输出。</strong></p><p>使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// export-default.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>与export命令的区别：其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// import-default.js</span><br><span class="hljs-keyword">import</span> customName <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./export-default&#x27;</span>;<br>customName(); <span class="hljs-comment">// &#x27;foo&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// modules.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123; <span class="hljs-keyword">return</span> x * y;<br>&#125;<br><span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;; <span class="hljs-comment">// 等同于 // export default add;</span><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>; <span class="hljs-comment">// 等同于 // import foo from &#x27;modules&#x27;;</span><br></code></pre></td></tr></table></figure><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><p><strong>总结：export命令对外接口是有名称的且<code>import</code>命令从模块导入的变量名与被导入模块对外接口的名称相同，而export default命令对外输出的变量名可以是任意的，这时<code>import</code>命令后面，不使用大括号。</strong></p><p><strong><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Taro-React框架的生命周期函数</title>
    <link href="/2022/02/21/Taro-React%E6%A1%86%E6%9E%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"/>
    <url>/2022/02/21/Taro-React%E6%A1%86%E6%9E%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="Taro-React框架的生命周期函数"><a href="#Taro-React框架的生命周期函数" class="headerlink" title="Taro-React框架的生命周期函数"></a>Taro-React框架的生命周期函数</h3><p>        最近接到一个小程序项目，考虑再三，决定使用Taro完成，主要的理由是，Taro支持React/Vue/Nerv 等框架来开发微信 、京东、百度、支付宝、字节、qq、飞书等小程序，以及H5、RN 等应用，可以做到一次编写，处处运行。</p><p>        官网的说法是这样的：</p><blockquote><p>现如今市面上端的形态多种多样，Web、React Native、微信小程序等各种端大行其道。当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。</p></blockquote><p>        于是我们愉快地开始了Taro的学习，无论学哪个框架，其中生命周期都是绕不开的地方，在Taro中，我们可以无障碍地直接使用小程序的生命周期，但在此基础上，Taro也新增了一系列的生命周期方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; View &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tarojs/components&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-comment">// 可以使用所有的 React 生命周期方法</span><br><br>  componentWillMount () &#123;&#125;<br><br>  componentDidMount () &#123;&#125;<br><br>  <span class="hljs-comment">// onLoad</span><br>  onLoad () &#123;&#125;<br><br>  <span class="hljs-comment">// onReady</span><br>  onReady () &#123;&#125;<br><br>  <span class="hljs-comment">// 对应 onShow</span><br>  componentDidShow () &#123;&#125;<br><br>  <span class="hljs-comment">// 对应 onHide</span><br>  componentDidHide () &#123;&#125;<br><br>  <span class="hljs-comment">// 对应 onPullDownRefresh，除了 componentDidShow/componentDidHide 之外，</span><br>  <span class="hljs-comment">// 所有页面生命周期函数名都与小程序相对应</span><br>  onPullDownRefresh () &#123;&#125;<br><br>  render () &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;index&#x27;</span> /&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Index<br></code></pre></td></tr></table></figure><p>这些方法的顺序，经过测试如下：componentWillMount——componentDidMount——onLoad——componentDidShow——onReady。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Taro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js 短路运算符</title>
    <link href="/2022/02/18/js%20%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2022/02/18/js%20%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="js-短路运算符"><a href="#js-短路运算符" class="headerlink" title="js 短路运算符"></a>js 短路运算符</h3><ul><li><h2 id="amp-amp-和-也叫短路运算符"><a href="#amp-amp-和-也叫短路运算符" class="headerlink" title="&amp;&amp; 和 || 也叫短路运算符"></a>&amp;&amp; 和 || 也叫短路运算符</h2></li><li><p><strong>短路&amp;&amp;： 只要碰到了假值(false)，就会短路，并返回该假值， 只要短路，不会继续执行后面的表达式。</strong></p></li><li><p><strong>短路||： 只要碰到了真值(true)，就会短路，并返回该真值， 只要短路，不会继续执行后面的表达式。</strong></p><p><strong>1、只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。<br>2、只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值;<br>3、只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。<br>4、只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值;</strong></p></li></ul><p>    注意：假值有以下6个：<br>    null undefined NaN false 0 ’ ’</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;abc&#x27;</span> &amp;&amp; <span class="hljs-literal">null</span>); <span class="hljs-comment">// null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-string">&#x27;abc&#x27;</span>); <span class="hljs-comment">// null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-literal">null</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> || <span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;abc&#x27;</span> || <span class="hljs-number">123</span>); <span class="hljs-comment">// ‘abc’</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> || <span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// &#x27;&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br> <span class="hljs-comment">// 真值短路</span><br> <span class="hljs-comment">// 短路或 || 经常用来设置函数参数的默认值</span><br> a = a || <span class="hljs-number">0</span>;<br> b = b || <span class="hljs-number">0</span>;<br> <span class="hljs-built_in">console</span>.log(a + b);<br> &#125;<br>add(); <span class="hljs-comment">// 0</span><br>add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br>add(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>); <span class="hljs-comment">// 300</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>短路运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链(Scope Chain)</title>
    <link href="/2022/02/06/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(Scope%20Chain)/"/>
    <url>/2022/02/06/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(Scope%20Chain)/</url>
    
    <content type="html"><![CDATA[<h3 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h3><ol><li><strong>定义</strong></li></ol><p>如果要简要的描述并展示其重点，那么作用域链大多数与内部函数相关。</p><p>我们知道，ECMAScript 允许创建内部函数，我们甚至能从父函数中返回这些函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <br> <span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;  <br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;  <br> alert(x + y);  <br> &#125;  <br> <span class="hljs-keyword">return</span> bar;  <br>&#125;<br><br>foo()(); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><p>这样，很明显每个上下文拥有自己的变量对象：对于全局上下文，它是全局对象自身；对于函数，它是活动对象。</p><p>作用域链正是内部上下文所有变量对象（包括父变量对象）的列表。此链用来变量查询。即在上面的例子中，“bar”上下文的作用域链包括AO(bar)、AO(foo)和VO(global)。</p><blockquote><p>作用域链与一个执行上下文相关，变量对象的链用于在标识符解析中变量查找。</p></blockquote><p><strong>函数上下文的作用域链在函数调用时创建的，包含活动对象和这个函数内部的[[scope]]属性。</strong>下面我们将更详细的讨论一个函数的[[scope]]属性。</p><p>在上下文中示意如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">activeExecutionContext = &#123;<br>    <span class="hljs-attr">VO</span>: &#123;...&#125;, <span class="hljs-comment">// or AO</span><br>    <span class="hljs-attr">this</span>: thisValue,<br>    <span class="hljs-attr">Scope</span>: [ <span class="hljs-comment">// Scope chain</span><br>      <span class="hljs-comment">// 所有变量对象的列表</span><br>      <span class="hljs-comment">// for identifiers lookup</span><br>    ]<br>&#125;;<br></code></pre></td></tr></table></figure><p>其scope定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Scope = AO + [[Scope]]<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>函数创建</strong></li></ol><p>众所周知，在进入上下文时函数声明放到变量/活动（VO/AO）对象中。让我们看看在全局上下文中的变量和函数声明（这里变量对象是全局对象自身，我们还记得，是吧？）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <br> <span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;  <br> alert(x + y);  <br>&#125;<br><br>foo(); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><p>在函数激活时，我们得到正确的（预期的）结果－－30。但是，有一个很重要的特点。  </p><p>此前，我们仅仅谈到有关当前上下文的变量对象。这里，我们看到变量“y”在函数“foo”中定义（意味着它在foo上下文的AO中），但是变量“x”并未在“foo”上下文中定义，相应地，它也不会添加到“foo”的AO中。乍一看，变量“x”相对于函数“foo”根本就不存在；但正如我们在下面看到的——也仅仅是“一瞥”，我们发现，“foo”上下文的活动对象中仅包含一个属性－－“y”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fooContext.AO = &#123;  <br>  <span class="hljs-attr">y</span>: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// undefined – 进入上下文的时候是20 – at activation  </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>函数“foo”如何访问到变量“x”？理论上函数应该能访问一个更高一层上下文的变量对象。实际上它正是这样，这种机制是通过函数内部的[[scope]]属性来实现的。</p><p>[[scope]]是所有父变量对象的层级链，处于当前函数上下文之上，在函数创建时存于其中。</p><p>注意这重要的一点－－[[scope]]在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁。即：函数可以永不调用，但[[scope]]属性已经写入，并存储在函数对象中。</p><p>另外一个需要考虑的是－－与作用域链对比，[[scope]]是函数的一个属性而不是上下文。考虑到上面的例子，函数“foo”的[[scope]]如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo.[[Scope]] = [  <br>  globalContext.VO <span class="hljs-comment">// === Global  </span><br>];<br></code></pre></td></tr></table></figure><p>举例来说，我们用通常的ECMAScript 数组展现作用域和[[scope]]…</p>]]></content>
    
    
    
    <tags>
      
      <tag>作用域链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript的垃圾回收机制</title>
    <link href="/2022/02/02/javascript%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/02/02/javascript%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="javascript的垃圾回收机制"><a href="#javascript的垃圾回收机制" class="headerlink" title="javascript的垃圾回收机制"></a>javascript的垃圾回收机制</h2><h4 id="一、垃圾回收的必要性"><a href="#一、垃圾回收的必要性" class="headerlink" title="一、垃圾回收的必要性"></a><strong>一、垃圾回收的必要性</strong></h4><p>　　下面这段话引自《JavaScript权威指南（第四版）》</p><blockquote><p> <em>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</em></p></blockquote><p>　　这段话解释了为什么需要系统需要垃圾回收，JS不像C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;before&quot;</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;override a&quot;</span>;<br><span class="hljs-keyword">var</span> a = b; <span class="hljs-comment">//重写a</span><br></code></pre></td></tr></table></figure><p>　　这段代码运行之后，“before”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。</p><h4 id="二、垃圾回收原理浅析"><a href="#二、垃圾回收原理浅析" class="headerlink" title="二、垃圾回收原理浅析"></a>二、<strong>垃圾回收原理浅析</strong></h4><p>　　现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。</p><p><strong>1、标记清除</strong></p><p>　　这是javascript中最常用的垃圾回收方式。当变量进入执行环境时，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。<br>　　垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p><p><strong>2、引用计数</strong></p><p>　　另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。<br>        <br>但是用这种方法存在着一个问题，下面来看看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">problem</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> objA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    <span class="hljs-keyword">var</span> objB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    objA.someOtherObject = objB;<br>    objB.anotherObject = objA;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。<br>        <br>　　我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Component Object  Model，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使IE的Javascript引擎使用标记清除的策略来实现的，但JavaScript访问的COM对象依然是基于引用计数的策略的。说白了，只要IE中涉及COM对象，就会存在循环引用的问题。看看下面的这个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;some_element&quot;</span>);<br><span class="hljs-keyword">var</span> myObj =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>myObj.element = element;<br>element.someObject = myObj;<br></code></pre></td></tr></table></figure><p>　　上面这个例子中，在一个DOM元素(element)与一个原生JavaScript对象(myObj)之间建立了循环引用。其中，变量myObj有一个名为element的属性指向element；而变量element有一个名为someObject的属性回指到myObj。由于循环引用，即使将例子中的DOM从页面中移除，内存也永远不会回收。<br>        <br>　　不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myObj.element = <span class="hljs-literal">null</span>;<br>element.someObject =<span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>　　这样写代码的话就可以解决循环引用的问题了，也就防止了内存泄露的问题。</p><p><strong>三、减少JavaScript中的垃圾回收</strong></p><p>　　首先，最明显的，new关键字就意味着一次内存分配，例如 new Foo()。最好的处理方法是：在初始化的时候新建对象，然后在后续过程中尽量多的重用这些创建好的对象。</p><p>另外还有以下三种内存分配表达式（可能不像new关键字那么明显了）：</p><ul><li>{} （创建一个新对象）</li><li>[] （创建一个新数组）</li><li>function() {…} (创建一个新的方法，注意：新建方法也会导致垃圾收集！！)</li></ul><p><strong>1、对象object优化</strong></p><p>　　为了最大限度的实现对象的重用，应该像避使用new语句一样避免使用{}来新建对象。</p><p>　　{“foo”:”bar”}这种方式新建的带属性的对象，常常作为方法的返回值来使用，可是这将会导致过多的内存创建，因此最好的解决办法是：每一次函数调用完成之后，将需要返回的数据放入一个全局的对象中，并返回此全局对象。如果使用这种方式，就意味着每一次方法调用都会导致全局对象内容的修改，这有可能会导致错误的发生。因此，一定要对此全局对象的使用进行详细的注释和说明。</p><p>　　有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。</p><p>　　cr.wipe(obj)方法就是为此功能而生，代码如下： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 删除obj对象的所有属性，高效的将obj转化为一个崭新的对象！</span><br>cr.wipe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> obj) &#123;<br>         <span class="hljs-keyword">if</span> (obj.hasOwnProperty(p))<br>            <span class="hljs-keyword">delete</span> obj[p];<br>    &#125;<br>&#125;; <br></code></pre></td></tr></table></figure><p>　　有些时候，你可以使用cr.wipe(obj)方法清理对象，再为obj添加新的属性，就可以达到重复利用对象的目的。虽然通过清空一个对象来获取“新对象”的做法，比简单的通过{}来创建对象要耗时一些，但是在实时性要求很高的代码中，这一点短暂的时间消耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停，这是非常值得的！</p><p><strong>2、数组array优化</strong></p><p>　　将[]赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），<strong>但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！</strong>实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p><p><strong>3、方法function优化</strong></p><p>　　方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。</p><p>　　在游戏的主循环中，setTimeout或requestAnimationFrame来调用一个成员方法是很常见的，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<br>    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">self</span>) </span>&#123;                    <br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>         self.tick();<br>    &#125;;<br>&#125;)(<span class="hljs-built_in">this</span>), <span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><p>　　每过16毫秒调用一次this.tick()，嗯，乍一看似乎没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！</p><p>　　为了解决这个问题，可以将作为返回值的方法保存起来，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// at startup</span><br><span class="hljs-built_in">this</span>.tickFunc = (<br>    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">self</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>         self.tick();<br>      &#125;;<br>    &#125;<br>)(<span class="hljs-built_in">this</span>);<br><span class="hljs-comment">// in the tick() function</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-built_in">this</span>.tickFunc, <span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>　　相比于每次都新建一个方法对象，这种方式在每一帧当中重用了相同的方法对象。这种方式的优势是显而易见的，而这种思想也可以应用在任何以方法为返回值或者在运行时创建方法的情况当中。</p><p><strong>4、高级技术</strong></p><p>　　从根本上来说，javascript本身就是围绕着垃圾收集来设计的。随着我们工作的进行，避免内存垃圾变得越来越困难。因为很多方便实用的Javascript库方法也会产生一些新的对象。对于这些库方法产生的垃圾，我们束手无策，只能重新翻看文档，并且检查方法的返回值。例如，数组的slice方法返回一个新的数组（在不修改原数组的基础上，截取出一部分作为新数组），字符串的substr方法返回一个新的字符串（在不修改原字符串的基础上，截取出一部分字符串作为返回值）等等。</p><p>　　调用这些库方法，将会创建内存垃圾，而你能做的，只有避免调用这些方法，或者用不创建系统垃圾的方式重写这些方法（有点极端啦~）。</p><p>　　例如，在Construct 2引擎中，从数组中利用下标来删除一个元素，是经常进行的操作。最初我们是用下面这种方式来实现的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sliced = arr.slice(index + <span class="hljs-number">1</span>);<br>arr.length = index;<br>arr.push.apply(arr, sliced);<br></code></pre></td></tr></table></figure><p>　　然而，slice方法会返回一个新的数组对象（数组中的元素是原数组中删掉的部分），并且会通过arr.push.apply方法将元素重新复制回原数组，但是在此操作之后，该数组就成为了一片内存垃圾。由于这是我们引擎中的垃圾产生的热点代码（使用频率非常很高），因此我们利用了迭代的方式重写了上述代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = index, len = arr.length – <span class="hljs-number">1</span>; i &lt; len; i++)<br>    arr[i] = arr[i + <span class="hljs-number">1</span>];<br>arr.length = len;<br></code></pre></td></tr></table></figure><p>　　显然，重写大量的库函数是非常痛苦的，因此你必须仔细权衡方法的易用性和内存垃圾产生情况。如果产生大量内存垃圾的方法在动画的每一帧中被多次调用，你可能就会兴高采烈的重写库函数啦。</p><p>　　在递归函数中，通过{}构造空对象，并在递归过程中传递数据，虽然是很方便的。但是更好的方式是：利用一个单独的数组对象作为堆栈，在递归过程中对数组进行push和pop操作。更进一步，不要调用array的pop方法（pop将会使得array的最后一个元素将会变成内存垃圾），而应该使用一个索引来记录数组的最后一个元素的位置，在pop时简单的将索引减一即可；类似的，将索引加1来代替array的push操作，只有当索引对应的元素不存在时，才执行真正的push为数组加入一个新元素。</p><p>　　另外，在任何时候，都应该避免使用向量对象（例如：包含x和y属性的vector2对象）。有些方法将向量对象作为方法返回值，既可以支持返回值的再次修改，又能够将需要的属性一次性返回，使用起来非常方便。但是有时候在一帧动画中，创建了成百上千个这样的向量对象，从而导致严重的垃圾回收性能问题，也是非常常见的。因此最好将这些方法分离成具有独立职责的功能个体，例如：利用getX()和getY()方法（返回具体数据）代替getPosition()方法（返回一个vector2对象）。</p><p><strong>四、总结</strong></p><p>　　在Javascript中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。</p><p>　　但是，为了减少内存垃圾，我们还是可以对javascript代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。</p><p>　　我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的javascript应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。</p><p>转载自：<a href="https://www.cnblogs.com/wp-js/p/7609534.html">javascript的垃圾回收机制 - 最爱小vue - 博客园</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prototype、getPrototypeOf和_proto_之间的不同</title>
    <link href="/2022/01/25/prototype%E3%80%81getPrototypeOf%E5%92%8C_proto_%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
    <url>/2022/01/25/prototype%E3%80%81getPrototypeOf%E5%92%8C_proto_%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="prototype、getPrototypeOf和-proto-之间的不同"><a href="#prototype、getPrototypeOf和-proto-之间的不同" class="headerlink" title="# prototype、getPrototypeOf和_proto_之间的不同"></a># prototype、getPrototypeOf和_proto_之间的不同</h3><p>在学习JavaScript的过程中，原型是如何也绕不过去的一个知识点。虽然现在ES6已经非常普及，许多js的程序员都已经不再用原型的知识点来编写代码了，但是充分的理解原型也是很有必要的，尤其是在阅读他人优秀的js代码时，理解原型能帮助我们更好的理解早期代码。而原型包括三个访问器，这三个访问器有时功能重叠，所以准确的理解并区分他们还是很有必要的。</p><p>这三个访问器就是<code>prototype</code>、<code>getPrototypeOf</code>和<code>__proto__</code>，从名字上可见这三个访问器都是对prototype这个单词做了一些变化，生成这样的属性方法名。为了测试这三个方法的输出，我们先来模拟创建一个存储用户数据User的类。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, passwordHash</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.passwordHash = passwordHash;<br>&#125;<br><br>User.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[User &#x27;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;]&#x27;</span>;<br>&#125;<br><br>User.prototype.checkPassword = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">password</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> hash(password) === <span class="hljs-built_in">this</span>.passwordHash;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们创建的这个User类的构造函数，接收两个参数，一个是用户名name，一个是密码的hash值，并且类中有两个方法<code>toString</code>以及<code>checkPassword</code>用来输出用户信息和检查密码。</p><p>如果这个时候我们打印这三个原型方法的日志会得到一样的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;Lix&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(u)); <span class="hljs-comment">// User &#123; toString: [Function], checkPassword: [Function] &#125;</span><br><br><span class="hljs-built_in">console</span>.log(u.__proto__); <span class="hljs-comment">// User &#123; toString: [Function], checkPassword: [Function] &#125;</span><br><br><span class="hljs-built_in">console</span>.log(User.prototype); <span class="hljs-comment">// User &#123; toString: [Function], checkPassword: [Function] &#125;</span><br></code></pre></td></tr></table></figure><p>既然他们的输出都一样，那么他们是否作用一样呢，我们可以来比较测试一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.getPrototypeOf(u) === User.prototype; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">u.__proto__ === User.prototype; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>既然这两个方法都跟我们User对象的原型相等，那么这三个属性的区别究竟是什么呢？别急，接下来就把结论告诉大家。</p><ul><li><code>C.prototype</code>用于建立由 <code>new C()</code> 创建的对象的原型。</li><li><code>Object.getPrototype(obj)</code>是ES5中用来获取obj对象的原型对象的标准方法。</li><li><code>obj.__proto__</code>是获取obj对象的原型对象的非标准方法。</li></ul><p>所以一般我们是不会直接访问<code>C.prototype</code>去获取原型对象的，在ES5的环境中，我们使用<code>Object.getPrototype(obj)</code>来获取原型对象，而在不支持ES5的环境中，我们可以考虑用<code>__proto__</code>这样的非标准方法来当做权宜之计，希望各位不明白的同学能牢记这些区别。</p>]]></content>
    
    
    
    <tags>
      
      <tag>prototype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>process.nextTick 与 setTimeout的优先级</title>
    <link href="/2022/01/24/process.nextTick%20%E4%B8%8E%20setTimeout%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2022/01/24/process.nextTick%20%E4%B8%8E%20setTimeout%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="process-nextTick-与-setTimeout的优先级"><a href="#process-nextTick-与-setTimeout的优先级" class="headerlink" title="process.nextTick 与 setTimeout的优先级"></a>process.nextTick 与 setTimeout的优先级</h3><p>请看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-comment">//主进程 执行 </span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>)   <span class="hljs-comment">//因为setTimeout是宏任务，所以加入宏任务队列1，[&#x27;2&#x27;]</span><br>   process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-comment">//因为 process.nextTick是微任务，所以加入微任务队列2，[&#x27;4&#x27;,&#x27;3&#x27;]</span><br>  &#125;)<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>) <span class="hljs-comment">//因为此处代码执行不属于异步，所以直接推入主程序执行，[&#x27;4&#x27;]</span><br>      resolve()<br>  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>) <span class="hljs-comment">// 因为promise then 是微任务，所以推入微任务队列2,[&#x27;4&#x27;,&#x27;3&#x27;,&#x27;5&#x27;]</span><br>  &#125;)<br>&#125;,<span class="hljs-number">0</span>)<br><span class="hljs-comment">// process.nextTick总是发生在所有异步任务之前</span><br>process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>)  <span class="hljs-comment">//因为process.nextTick是微任务，所以推入微任务队列1,[&#x27;6&#x27;]</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>)<span class="hljs-comment">//因为此处代码执行不属于异步，所以直接推入主程序执行，[&#x27;6&#x27;,&#x27;7&#x27;]</span><br>    resolve()<br>  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)<span class="hljs-comment">//因为 promise then 是微任务，所以推入微任务队列1,[&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;]</span><br>  &#125;)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>)<span class="hljs-comment">//因为setTimeout是宏任务，所以推入宏任务队列2 ，[&#x27;9&#x27;]</span><br>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>)<span class="hljs-comment">//因为process.nextTick是微任务，所以推入微任务队列3，[&#x27;9&#x27;,&#x27;11&#x27;,&#x27;12&#x27;,&#x27;10&#x27;]</span><br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>)<span class="hljs-comment">//因为此处代码执行不属于异步，所以直接推入主程序执行,[&#x27;9&#x27;,&#x27;11&#x27;]</span><br>      resolve()<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;12&#x27;</span>)<span class="hljs-comment">////因为此处代码执行不属于异步，所以直接推入主程序执行,[&#x27;9&#x27;,&#x27;11&#x27;,&#x27;12&#x27;]</span><br>    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;13&#x27;</span>)<span class="hljs-comment">//因为 promise then 是微任务，所以推入微任务队列3,[&#x27;9&#x27;,&#x27;11&#x27;,&#x27;12&#x27;,&#x27;10&#x27;,&#x27;12&#x27;]</span><br>    &#125;)<br>  &#125;,<span class="hljs-number">0</span>)<br>&#125;)<br><br><span class="hljs-comment">//打印输出</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 6</span><br><span class="hljs-comment">// 7</span><br><span class="hljs-comment">// 8</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 4</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 9</span><br><span class="hljs-comment">// 11</span><br><span class="hljs-comment">// 12</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><p>得出结论：微任务优先级大小：process.nextTick &gt; setTimeout</p>]]></content>
    
    
    
    <tags>
      
      <tag>setTimeout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS类选择器的小细节</title>
    <link href="/2022/01/18/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <url>/2022/01/18/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS类选择器的小细节"><a href="#CSS类选择器的小细节" class="headerlink" title="CSS类选择器的小细节"></a>CSS类选择器的小细节</h3><p><strong>1、我们看一个示例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br>.<span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，无效的类选择器 <code>..special</code> 规则将被忽略，而 <code>h1</code> 仍会设置样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>, .<span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，上述例子所示，当组合在一起时， <code>h1</code> 由于整个规则被认为是无效的，因此和类都不会被设置样式，即这整个代码块都是无效的。</p><p><strong>2、属性选择器</strong></p><p>属性选择器选择器提供了基于元素上某个属性的存在来选择元素的不同方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p><strong>或者甚至根据具有特定值的属性的存在进行选择：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;https://example.com&quot;</span>]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p><strong>3、伪类和伪元素</strong></p><p>伪类，例如，<code>:hover</code>伪类仅在鼠标指针悬停时选择元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>伪元素选择元素的某个部分而不是元素本身。例如，<code>::first-line</code>始终选择元素内的第一行文本</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue;<br> &#125;<br></code></pre></td></tr></table></figure><p>此时p标签的第一行文字为蓝色，其他部分颜色默认。</p><p><strong>4、::first-of-type</strong></p><p> <code>first-of-type</code> 表示一组兄弟元素中其类型的第一个元素。</p><p>例如HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-of-type &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-style</span>: italic;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/img/css-first.jpg" alt="result"></p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object的Create()方法</title>
    <link href="/2022/01/17/Object%E7%9A%84Create()%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/17/Object%E7%9A%84Create()%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="Object的Create-方法"><a href="#Object的Create-方法" class="headerlink" title="Object的Create()方法"></a>Object的Create()方法</h3><p>from MDN</p><blockquote><p>此方法创建一个新对象，使用现有的对象来提供新创建的对象的_proto_</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">isHuman</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">printIntroduction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>. Am I human? <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.isHuman&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> me = <span class="hljs-built_in">Object</span>.create(person);<br><br>me.name = <span class="hljs-string">&#x27;Matthew&#x27;</span>; <span class="hljs-comment">// &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;</span><br>me.isHuman = <span class="hljs-literal">true</span>; <span class="hljs-comment">// inherited properties can be overwritten</span><br><br>me.printIntroduction();<br><span class="hljs-comment">// expected output: &quot;My name is Matthew. Am I human? true&quot;</span><br><br></code></pre></td></tr></table></figure><p>用 <code>Object.create</code>实现类式继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Shape - 父类(superclass)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">this</span>.y = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 父类的方法</span><br>Shape.prototype.move = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x += x;<br>  <span class="hljs-built_in">this</span>.y += y;<br>  <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;Shape moved.&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// Rectangle - 子类(subclass)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"></span>) </span>&#123;<br>  Shape.call(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// call super constructor.</span><br>&#125;<br><br><span class="hljs-comment">// 子类续承父类</span><br>Rectangle.prototype = <span class="hljs-built_in">Object</span>.create(Shape.prototype);<br>Rectangle.prototype.constructor = Rectangle;<br><br><span class="hljs-keyword">var</span> rect = <span class="hljs-keyword">new</span> Rectangle();<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Is rect an instance of Rectangle?&#x27;</span>,<br>  rect <span class="hljs-keyword">instanceof</span> Rectangle); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Is rect an instance of Shape?&#x27;</span>,<br>  rect <span class="hljs-keyword">instanceof</span> Shape); <span class="hljs-comment">// true</span><br>rect.move(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Outputs, &#x27;Shape moved.&#x27;</span><br></code></pre></td></tr></table></figure><p>如果希望能继承到多个对象，则可以使用混入的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>) </span>&#123;<br>     SuperClass.call(<span class="hljs-built_in">this</span>);<br>     OtherSuperClass.call(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 继承一个类</span><br>MyClass.prototype = <span class="hljs-built_in">Object</span>.create(SuperClass.prototype);<br><span class="hljs-comment">// 混合其它</span><br><span class="hljs-built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);<br><span class="hljs-comment">// 重新指定constructor</span><br>MyClass.prototype.constructor = MyClass;<br><br>MyClass.prototype.myMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-comment">// do a thing</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 会把 <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。Object.assign 是在 ES2015 引入的，且可用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#polyfill">polyfilled</a>。要支持旧浏览器的话，可用使用 <a href="https://api.jquery.com/jQuery.extend/">jQuery.extend()</a> 或者 <a href="https://lodash.com/docs/#assign">_.assign()</a>。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>querySelector与getElementById的区别</title>
    <link href="/2022/01/15/querySelector%E4%B8%8EgetElementById%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/15/querySelector%E4%B8%8EgetElementById%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="querySelector与getElementById的区别"><a href="#querySelector与getElementById的区别" class="headerlink" title="querySelector与getElementById的区别"></a>querySelector与getElementById的区别</h3><p>今天学习过程中，发现了一种获取dom元素时，我不经常使用的document.querySelector方法，乍一看querySelector还以为是jquery中的方法，谁让他们的名字都有个query。那么querySelector 和 getElementById究竟有什么区别？</p><p>查阅文档：</p><blockquote><ol><li>querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。<br>注意： querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。<br>querySelectorAll() 方法返回文档中匹配指定 CSS 选择器的所有元素，返回 [NodeList] 对象。<br>2.[document.getElementsByClassName()]： 返回文档中所有指定类名的元素集合，作为 NodeList 对象。<br>[document.getElementById()]：返回对拥有指定 id 的第一个对象的引用。<br>[document.getElementsByName()]：返回带有指定名称的对象集合。<br>[document.getElementsByTagName()]：返回带有指定标签名的对象集合。</li></ol></blockquote><p>看似还是找不到区别，好在万能的搜索引擎告诉了我答案</p><p><strong>query选择符选出来的元素及元素数组是静态的，而getElement这种方法选出的元素是动态的。</strong></p><p>看一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;aa&quot;</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> querySelector = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#test&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-keyword">var</span> getElementById = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(querySelector === getElementById) <span class="hljs-comment">// true</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> querySelectorAll = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;p&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i &lt; querySelectorAll.length;i++)&#123;</span><br><span class="javascript">        querySelector.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>))</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(querySelectorAll.length) <span class="hljs-comment">//值为2,动态添加元素并没有使querySelectorAll发生变化</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> getElementsByTagName = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;p&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++)&#123;</span><br><span class="javascript">        getElementById.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>))</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(getElementsByTagName.length) <span class="hljs-comment">//值为4+3=7,每次动态添加元素都使getElementsByTagName发生了变化</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：由于querySelector是按照CSS规范来实现的，所以它传入的字符串第一个字符不能是数字。</p><p>再看一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-comment">//获取到ul，为了之后动态的添加li</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box&#x27;</span>);</span><br><span class="javascript"><span class="hljs-comment">//获取到现有ul里面的li</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> list = ul.getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>);</span><br><span class="javascript">     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="javascript">        ul.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>)); <span class="hljs-comment">//动态追加li</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码会陷入死循环，注意for中的循环条件list.length，在第一次获取到里面的3个li后，每当往ul里添加了新元素后，list便会更新其值，重新获取ul里的所有li。也就是getElement(s)Byxxxx获取的是动态集合，它总会随着dom结构的变化而变化。即每一次调用list都会重新对文档进行查询，导致无限循环的问题。</p><p>修改：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-comment">//获取到ul，为了之后动态的添加li</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box&#x27;</span>);</span><br><span class="javascript"><span class="hljs-comment">//获取到现有ul里面的li</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> list = ul.getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>);</span><br><span class="javascript">     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;</span><br><span class="javascript">        ul.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>)); <span class="hljs-comment">//动态追加li</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(list.length); <span class="hljs-comment">//7</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将for循环条件修改后，新在ul里添加了4个元素，所有现在打印出来的长度为7。</p><p>修改2：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-comment">//获取到ul，为了之后动态的添加li</span></span><br><span class="javascript">     <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);</span><br><span class="javascript"><span class="hljs-comment">//获取到现有ul里面的所有li</span></span><br><span class="javascript">     <span class="hljs-keyword">var</span> list = ul.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>);</span><br><span class="javascript">     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="javascript">         ul.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>));<span class="hljs-comment">//动态追加li</span></span><br><span class="javascript">     &#125;</span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(list.length); <span class="hljs-comment">//输出的结果仍然是3，不是此时li的数量6</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码静态集合体现在.querySelectorAll(‘li’)获取到ul里所有li后，不管后续再动态添加了多少li，都不会对其参数影响。</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章回顾TypeScript基本用法</title>
    <link href="/2022/01/11/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%9B%9E%E9%A1%BETypeScript%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2022/01/11/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%9B%9E%E9%A1%BETypeScript%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一篇文章回顾TypeScript基本用法"><a href="#一篇文章回顾TypeScript基本用法" class="headerlink" title="一篇文章回顾TypeScript基本用法"></a>一篇文章回顾TypeScript基本用法</h3><p>TypeScript 是一门为开发大型 JavaScript 应用而设计的语言。TypeScript 在 JavaScript 的基础上增加了类、模块、接口、泛型和静态类型等常见的概念。它是 JavaScript 的超集：所有 JavaScript 代码都是有效的 TypeScript 代码，因此任何 JavaScript 项目都可以无缝引入 TypeScript，TypeScript 编译器最终会把 TypeScript 代码编译成 JavaScript 代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// TypeScript 有三种基本类型，布尔类型、数值类型、字符串类型</span><br><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> lines: <span class="hljs-built_in">number</span> = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">let</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Anders&#x27;</span>;<br><br><span class="hljs-comment">// 如果不知道是什么类型，可以使用 &quot;any&quot; (任意)类型</span><br><span class="hljs-keyword">let</span> notSure: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;<br>notSure = <span class="hljs-string">&#x27;可以重新赋值，转换为字符串类型&#x27;</span>;<br>notSure = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 亦可，重新定义为布尔类型</span><br><br><span class="hljs-comment">// 使用 const 关键字将一个字面量修饰为常量</span><br><span class="hljs-keyword">const</span> numLivesForCat = <span class="hljs-number">9</span>;<br>numLivesForCat = <span class="hljs-number">1</span>; <span class="hljs-comment">// 常量不能重新被赋值，所以这里会报错</span><br><br><span class="hljs-comment">// TypeScript 中的 collection 有两种表示形式, 一种是有类型的数组，另一种是泛型数组</span><br><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// 或者，使用泛型数组</span><br><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// 枚举：</span><br><span class="hljs-built_in">enum</span> Color &#123;Red, Green, Blue&#125;<br><span class="hljs-keyword">let</span> c: Color = Color.Green;<br><br><span class="hljs-comment">// 最后是 &quot;void&quot;，它用于表明函数没有任何返回值的特殊情况</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bigHorribleAlert</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>  alert(<span class="hljs-string">&#x27;我是个烦人的弹出框！&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 函数是&quot;一等公民&quot;(first class citizens), 支持使用 lambda 胖箭头表达式和类型推断</span><br><br><span class="hljs-comment">// 以下 f1-f5 五个函数是等价的，TypeScript 编译器会把它们编译成相同的 JavaScript 代码(可以到 Playground 验证)</span><br><span class="hljs-comment">// 一般的函数</span><br><span class="hljs-keyword">let</span> f1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123; <span class="hljs-keyword">return</span> i * i; &#125;;<br><span class="hljs-comment">// 根据返回值推断函数返回类型</span><br><span class="hljs-keyword">let</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i: <span class="hljs-built_in">number</span></span>) </span>&#123; <span class="hljs-keyword">return</span> i * i; &#125;;<br><span class="hljs-comment">// 胖箭头表达式</span><br><span class="hljs-keyword">let</span> f3 = (i: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> &#123; <span class="hljs-keyword">return</span> i * i; &#125;;<br><span class="hljs-comment">// 根据返回值推断返回类型的胖箭头表达式</span><br><span class="hljs-keyword">let</span> f4 = <span class="hljs-function">(<span class="hljs-params">i: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> i * i; &#125;;<br><span class="hljs-comment">// 根据返回值推断返回类型的胖箭头表达式, 省略花括号的同时，可以同时省去 return 关键字</span><br><span class="hljs-keyword">let</span> f5 = <span class="hljs-function">(<span class="hljs-params">i: <span class="hljs-built_in">number</span></span>) =&gt;</span>  i * i;<br><br><span class="hljs-comment">// 接口是结构化的，任何具备接口中声明的全部属性的对象，都与该接口兼容</span><br><span class="hljs-keyword">interface</span> Person &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// 使用 &quot;?&quot; 标识，表明该属性是一个非必需属性</span><br>  age?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 函数</span><br>  move(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现 &quot;Person&quot; 接口的对象，当它具备 &quot;name&quot; 属性和 &quot;move&quot; 方法之后可被视为一个 &quot;Person&quot;</span><br><span class="hljs-keyword">let</span> p: Person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bobby&#x27;</span>, <span class="hljs-attr">move</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125;;<br><span class="hljs-comment">// 带可选属性的对象</span><br><span class="hljs-keyword">let</span> validPerson: Person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bobby&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">move</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125;;<br><span class="hljs-comment">// 由于该对象 &quot;age&quot; 属性的类型不是 &quot;number&quot; ，所以这不是一个 &quot;Person&quot;</span><br><span class="hljs-keyword">let</span> invalidPerson: Person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bobby&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-literal">true</span> &#125;;<br><br><span class="hljs-comment">// 接口同样可以描述一个函数的类型</span><br><span class="hljs-keyword">interface</span> SearchFunc &#123;<br>  (source: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-comment">// 参数名并不重要，参数类型才是最重要的</span><br><span class="hljs-keyword">let</span> mySearch: SearchFunc;<br>mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src: <span class="hljs-built_in">string</span>, sub: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> src.search(sub) !== -<span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 类 - 成员访问权限默认都是公共的 (public)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-comment">// 成员属性</span><br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-comment">// 构造器 - 在构造器中使用 public/private 关键字修饰的变量，会被声明为类的成员属性。</span><br>  <span class="hljs-comment">// 下面这个例子中，y 会像 x 一样被声明定义为类成员属性，而不再需要额外代码</span><br>  <span class="hljs-comment">// 声明时，同样支持指定默认值</span><br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, <span class="hljs-keyword">public</span> y: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.x = x;<br>  &#125;<br><br>  <span class="hljs-comment">// 成员函数</span><br>  <span class="hljs-function"><span class="hljs-title">dist</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-built_in">this</span>.x * <span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y * <span class="hljs-built_in">this</span>.y); &#125;<br><br>  <span class="hljs-comment">// 静态成员</span><br>  <span class="hljs-keyword">static</span> origin = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">10</span> , <span class="hljs-number">20</span>);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">25</span>); <span class="hljs-comment">// y 为构造器中指定的默认值：0</span><br><br><span class="hljs-comment">// 继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point3D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, <span class="hljs-keyword">public</span> z: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">// 必须显式调用父类的构造器</span><br>  &#125;<br><br>  <span class="hljs-comment">// 重写父类中的 dist() 函数</span><br>  <span class="hljs-function"><span class="hljs-title">dist</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">super</span>.dist();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(d * d + <span class="hljs-built_in">this</span>.z * <span class="hljs-built_in">this</span>.z);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 模块, &quot;.&quot; 符号可以作为子模块的分隔符</span><br><span class="hljs-built_in">module</span> Geometry &#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> sideLength: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">area</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(<span class="hljs-built_in">this</span>.sideLength, <span class="hljs-number">2</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-keyword">new</span> Geometry.Square(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 为模块创建一个本地别名</span><br><span class="hljs-keyword">import</span> G = Geometry;<br><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-keyword">new</span> G.Square(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 泛型</span><br><span class="hljs-comment">// 类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tuple</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> item1: T1, <span class="hljs-keyword">public</span> item2: T2</span>)</span> &#123;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">interface</span> Pair&lt;T&gt; &#123;<br>  <span class="hljs-attr">item1</span>: T;<br>  item2: T;<br>&#125;<br><br><span class="hljs-comment">// 以及函数</span><br><span class="hljs-keyword">let</span> pairToTuple = <span class="hljs-function"><span class="hljs-keyword">function</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">p: Pair&lt;T&gt;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Tuple(p.item1, p.item2);<br>&#125;;<br><br><span class="hljs-keyword">let</span> tuple = pairToTuple(&#123; <span class="hljs-attr">item1</span>: <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-attr">item2</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;);<br><br><span class="hljs-comment">// 引用定义文件</span><br><span class="hljs-comment">/// &lt;reference path=&quot;jquery.d.ts&quot; /&gt;</span><br><br><span class="hljs-comment">// 模板字符串(使用反引号的字符串)</span><br><span class="hljs-comment">// 嵌入变量的模板字符串</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Tyrone&#x27;</span>;<br><span class="hljs-keyword">let</span> greeting = <span class="hljs-string">`Hi <span class="hljs-subst">$&#123;name&#125;</span>, how are you?`</span>;<br><span class="hljs-comment">// 有多行内容的模板字符串</span><br><span class="hljs-keyword">let</span> multiline = <span class="hljs-string">`This is an example</span><br><span class="hljs-string">of a multiline string`</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新建文件夹——搭建前端UI组件库</title>
    <link href="/2022/01/10/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AFUI%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    <url>/2022/01/10/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AFUI%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="新建文件夹——搭建前端UI组件库"><a href="#新建文件夹——搭建前端UI组件库" class="headerlink" title="新建文件夹——搭建前端UI组件库"></a>新建文件夹——搭建前端UI组件库</h3><p>目前市面上有很多功能强大且完善的组件库供我们使用，比如基于React的antd，material（个人更喜欢这个），基于Vue的elementUI、iView等。</p><p>为啥我们想做一个自己的组件库呢？有大佬给出的观点如下：</p><blockquote><p>我们使用第三方组件库搭建一个企业级应用是完全没有问题的，但是另一方面，随着我们对用户体验以及网站性能的要求越来越高，流量及金钱，速度即王道，对于专注于做C端的企业来说，尽可能的减少用户等待才能留住更多的用户，比如我们在某宝，某东上买一个商品，结果我们花了一分钟商品列表还没有出来（形容的有点夸张），这种情况下客户可有可能直接选择某拼了。很明显像ant-design和elementUI这样的组件不适合做C端产品，因为体积太大了，除非用高性能服务器或者其他方式弥补。</p></blockquote><p>嗯，虽然我们目前还不会接触到这样大规模的商城页面开发，但要面向未来嘛，另外通过做组件库，也能学到不少东西（吧）</p><p>我喜欢前端，其实说到底，喜欢的是设计，是界面，所以做组件库，真是到我心坎里了w</p><p>搞一个属于自己风格的组件库，想想就刺激</p><p>开个头吧，已经真 · 新建文件夹了 ↓</p><p><img src="/img/aemonUI.jpg" alt="我是图片"></p><p>哈哈哈哈，话不多说，冲~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>UI component</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello,zyc</title>
    <link href="/2022/01/09/hello-zyc/"/>
    <url>/2022/01/09/hello-zyc/</url>
    
    <content type="html"><![CDATA[<p>This is my first article in hexo !<br>Hello, nice to meet you, I am zyc.</p><h2 id="and-I-want-to-have-a-try"><a href="#and-I-want-to-have-a-try" class="headerlink" title="and I want to have a try"></a>and I want to have a try</h2><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>About me: <a href="https://github.com/lovesatoriforever">Github</a></p><h2 id="Have-fun"><a href="#Have-fun" class="headerlink" title="Have fun!"></a>Have fun!</h2>]]></content>
    
    
    
    <tags>
      
      <tag>first</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/01/09/hello-world/"/>
    <url>/2022/01/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
