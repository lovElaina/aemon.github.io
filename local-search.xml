<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>export 和 export default 的区别</title>
    <link href="/2022/02/22/export%20%E5%92%8C%20export%20default%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/02/22/export%20%E5%92%8C%20export%20default%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="export-和-export-default-的区别"><a href="#export-和-export-default-的区别" class="headerlink" title="export 和 export default 的区别"></a>export 和 export default 的区别</h3><p><strong><code>export</code>命令用于规定模块的对外接口。</strong></p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br></code></pre></td></tr></table></figure><p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p><p><code>export</code>的写法，除了像上面这样，还有另外一种。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><span class="hljs-keyword">export</span> &#123;firstName, lastName, year&#125;;<br></code></pre></td></tr></table></figure><p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p><p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x * y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码对外输出一个函数<code>multiply</code>。</p><p><code>export</code>命令对外输出了指定名字的变量（变量也可以是函数或类）。</p><p>与export default命令的区别：<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; lastName <span class="hljs-keyword">as</span> surname &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong><code>export default</code>命令，为模块指定默认输出。</strong></p><p>使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// export-default.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>与export命令的区别：其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// import-default.js</span><br><span class="hljs-keyword">import</span> customName <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./export-default&#x27;</span>;<br>customName(); <span class="hljs-comment">// &#x27;foo&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// modules.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123; <span class="hljs-keyword">return</span> x * y;<br>&#125;<br><span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;; <span class="hljs-comment">// 等同于 // export default add;</span><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>; <span class="hljs-comment">// 等同于 // import foo from &#x27;modules&#x27;;</span><br></code></pre></td></tr></table></figure><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><p><strong>总结：export命令对外接口是有名称的且<code>import</code>命令从模块导入的变量名与被导入模块对外接口的名称相同，而export default命令对外输出的变量名可以是任意的，这时<code>import</code>命令后面，不使用大括号。</strong></p><p><strong><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js 短路运算符</title>
    <link href="/2022/02/18/js%20%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2022/02/18/js%20%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="js-短路运算符"><a href="#js-短路运算符" class="headerlink" title="js 短路运算符"></a>js 短路运算符</h3><ul><li><h2 id="amp-amp-和-也叫短路运算符"><a href="#amp-amp-和-也叫短路运算符" class="headerlink" title="&amp;&amp; 和 || 也叫短路运算符"></a>&amp;&amp; 和 || 也叫短路运算符</h2></li><li><p><strong>短路&amp;&amp;： 只要碰到了假值(false)，就会短路，并返回该假值， 只要短路，不会继续执行后面的表达式。</strong></p></li><li><p><strong>短路||： 只要碰到了真值(true)，就会短路，并返回该真值， 只要短路，不会继续执行后面的表达式。</strong></p><p><strong>1、只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。<br>2、只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值;<br>3、只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。<br>4、只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值;</strong></p></li></ul><p>    注意：假值有以下6个：<br>    null undefined NaN false 0 ’ ’</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;abc&#x27;</span> &amp;&amp; <span class="hljs-literal">null</span>); <span class="hljs-comment">// null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-string">&#x27;abc&#x27;</span>); <span class="hljs-comment">// null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-literal">null</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> || <span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;abc&#x27;</span> || <span class="hljs-number">123</span>); <span class="hljs-comment">// ‘abc’</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> || <span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// &#x27;&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br> <span class="hljs-comment">// 真值短路</span><br> <span class="hljs-comment">// 短路或 || 经常用来设置函数参数的默认值</span><br> a = a || <span class="hljs-number">0</span>;<br> b = b || <span class="hljs-number">0</span>;<br> <span class="hljs-built_in">console</span>.log(a + b);<br> &#125;<br>add(); <span class="hljs-comment">// 0</span><br>add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br>add(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>); <span class="hljs-comment">// 300</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>短路运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链(Scope Chain)</title>
    <link href="/2022/02/06/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(Scope%20Chain)/"/>
    <url>/2022/02/06/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(Scope%20Chain)/</url>
    
    <content type="html"><![CDATA[<h3 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h3><ol><li><strong>定义</strong></li></ol><p>如果要简要的描述并展示其重点，那么作用域链大多数与内部函数相关。</p><p>我们知道，ECMAScript 允许创建内部函数，我们甚至能从父函数中返回这些函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <br> <span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;  <br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;  <br> alert(x + y);  <br> &#125;  <br> <span class="hljs-keyword">return</span> bar;  <br>&#125;<br><br>foo()(); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><p>这样，很明显每个上下文拥有自己的变量对象：对于全局上下文，它是全局对象自身；对于函数，它是活动对象。</p><p>作用域链正是内部上下文所有变量对象（包括父变量对象）的列表。此链用来变量查询。即在上面的例子中，“bar”上下文的作用域链包括AO(bar)、AO(foo)和VO(global)。</p><blockquote><p>作用域链与一个执行上下文相关，变量对象的链用于在标识符解析中变量查找。</p></blockquote><p><strong>函数上下文的作用域链在函数调用时创建的，包含活动对象和这个函数内部的[[scope]]属性。</strong>下面我们将更详细的讨论一个函数的[[scope]]属性。</p><p>在上下文中示意如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">activeExecutionContext = &#123;<br>    <span class="hljs-attr">VO</span>: &#123;...&#125;, <span class="hljs-comment">// or AO</span><br>    <span class="hljs-attr">this</span>: thisValue,<br>    <span class="hljs-attr">Scope</span>: [ <span class="hljs-comment">// Scope chain</span><br>      <span class="hljs-comment">// 所有变量对象的列表</span><br>      <span class="hljs-comment">// for identifiers lookup</span><br>    ]<br>&#125;;<br></code></pre></td></tr></table></figure><p>其scope定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Scope = AO + [[Scope]]<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>函数创建</strong></li></ol><p>众所周知，在进入上下文时函数声明放到变量/活动（VO/AO）对象中。让我们看看在全局上下文中的变量和函数声明（这里变量对象是全局对象自身，我们还记得，是吧？）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <br> <span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;  <br> alert(x + y);  <br>&#125;<br><br>foo(); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><p>在函数激活时，我们得到正确的（预期的）结果－－30。但是，有一个很重要的特点。  </p><p>此前，我们仅仅谈到有关当前上下文的变量对象。这里，我们看到变量“y”在函数“foo”中定义（意味着它在foo上下文的AO中），但是变量“x”并未在“foo”上下文中定义，相应地，它也不会添加到“foo”的AO中。乍一看，变量“x”相对于函数“foo”根本就不存在；但正如我们在下面看到的——也仅仅是“一瞥”，我们发现，“foo”上下文的活动对象中仅包含一个属性－－“y”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fooContext.AO = &#123;  <br>  <span class="hljs-attr">y</span>: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// undefined – 进入上下文的时候是20 – at activation  </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>函数“foo”如何访问到变量“x”？理论上函数应该能访问一个更高一层上下文的变量对象。实际上它正是这样，这种机制是通过函数内部的[[scope]]属性来实现的。</p><p>[[scope]]是所有父变量对象的层级链，处于当前函数上下文之上，在函数创建时存于其中。</p><p>注意这重要的一点－－[[scope]]在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁。即：函数可以永不调用，但[[scope]]属性已经写入，并存储在函数对象中。</p><p>另外一个需要考虑的是－－与作用域链对比，[[scope]]是函数的一个属性而不是上下文。考虑到上面的例子，函数“foo”的[[scope]]如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo.[[Scope]] = [  <br>  globalContext.VO <span class="hljs-comment">// === Global  </span><br>];<br></code></pre></td></tr></table></figure><p>举例来说，我们用通常的ECMAScript 数组展现作用域和[[scope]]…</p>]]></content>
    
    
    
    <tags>
      
      <tag>作用域链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript的垃圾回收机制</title>
    <link href="/2022/02/02/javascript%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/02/02/javascript%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="javascript的垃圾回收机制"><a href="#javascript的垃圾回收机制" class="headerlink" title="javascript的垃圾回收机制"></a>javascript的垃圾回收机制</h2><h4 id="一、垃圾回收的必要性"><a href="#一、垃圾回收的必要性" class="headerlink" title="一、垃圾回收的必要性"></a><strong>一、垃圾回收的必要性</strong></h4><p>　　下面这段话引自《JavaScript权威指南（第四版）》</p><blockquote><p> <em>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</em></p></blockquote><p>　　这段话解释了为什么需要系统需要垃圾回收，JS不像C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;before&quot;</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;override a&quot;</span>;<br><span class="hljs-keyword">var</span> a = b; <span class="hljs-comment">//重写a</span><br></code></pre></td></tr></table></figure><p>　　这段代码运行之后，“before”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。</p><h4 id="二、垃圾回收原理浅析"><a href="#二、垃圾回收原理浅析" class="headerlink" title="二、垃圾回收原理浅析"></a>二、<strong>垃圾回收原理浅析</strong></h4><p>　　现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。</p><p><strong>1、标记清除</strong></p><p>　　这是javascript中最常用的垃圾回收方式。当变量进入执行环境时，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。<br>　　垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p><p><strong>2、引用计数</strong></p><p>　　另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。<br>        <br>但是用这种方法存在着一个问题，下面来看看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">problem</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> objA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    <span class="hljs-keyword">var</span> objB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    objA.someOtherObject = objB;<br>    objB.anotherObject = objA;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。<br>        <br>　　我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Component Object  Model，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使IE的Javascript引擎使用标记清除的策略来实现的，但JavaScript访问的COM对象依然是基于引用计数的策略的。说白了，只要IE中涉及COM对象，就会存在循环引用的问题。看看下面的这个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;some_element&quot;</span>);<br><span class="hljs-keyword">var</span> myObj =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>myObj.element = element;<br>element.someObject = myObj;<br></code></pre></td></tr></table></figure><p>　　上面这个例子中，在一个DOM元素(element)与一个原生JavaScript对象(myObj)之间建立了循环引用。其中，变量myObj有一个名为element的属性指向element；而变量element有一个名为someObject的属性回指到myObj。由于循环引用，即使将例子中的DOM从页面中移除，内存也永远不会回收。<br>        <br>　　不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myObj.element = <span class="hljs-literal">null</span>;<br>element.someObject =<span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>　　这样写代码的话就可以解决循环引用的问题了，也就防止了内存泄露的问题。</p><p><strong>三、减少JavaScript中的垃圾回收</strong></p><p>　　首先，最明显的，new关键字就意味着一次内存分配，例如 new Foo()。最好的处理方法是：在初始化的时候新建对象，然后在后续过程中尽量多的重用这些创建好的对象。</p><p>另外还有以下三种内存分配表达式（可能不像new关键字那么明显了）：</p><ul><li>{} （创建一个新对象）</li><li>[] （创建一个新数组）</li><li>function() {…} (创建一个新的方法，注意：新建方法也会导致垃圾收集！！)</li></ul><p><strong>1、对象object优化</strong></p><p>　　为了最大限度的实现对象的重用，应该像避使用new语句一样避免使用{}来新建对象。</p><p>　　{“foo”:”bar”}这种方式新建的带属性的对象，常常作为方法的返回值来使用，可是这将会导致过多的内存创建，因此最好的解决办法是：每一次函数调用完成之后，将需要返回的数据放入一个全局的对象中，并返回此全局对象。如果使用这种方式，就意味着每一次方法调用都会导致全局对象内容的修改，这有可能会导致错误的发生。因此，一定要对此全局对象的使用进行详细的注释和说明。</p><p>　　有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。</p><p>　　cr.wipe(obj)方法就是为此功能而生，代码如下： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 删除obj对象的所有属性，高效的将obj转化为一个崭新的对象！</span><br>cr.wipe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> obj) &#123;<br>         <span class="hljs-keyword">if</span> (obj.hasOwnProperty(p))<br>            <span class="hljs-keyword">delete</span> obj[p];<br>    &#125;<br>&#125;; <br></code></pre></td></tr></table></figure><p>　　有些时候，你可以使用cr.wipe(obj)方法清理对象，再为obj添加新的属性，就可以达到重复利用对象的目的。虽然通过清空一个对象来获取“新对象”的做法，比简单的通过{}来创建对象要耗时一些，但是在实时性要求很高的代码中，这一点短暂的时间消耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停，这是非常值得的！</p><p><strong>2、数组array优化</strong></p><p>　　将[]赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），<strong>但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！</strong>实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p><p><strong>3、方法function优化</strong></p><p>　　方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。</p><p>　　在游戏的主循环中，setTimeout或requestAnimationFrame来调用一个成员方法是很常见的，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<br>    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">self</span>) </span>&#123;                    <br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>         self.tick();<br>    &#125;;<br>&#125;)(<span class="hljs-built_in">this</span>), <span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><p>　　每过16毫秒调用一次this.tick()，嗯，乍一看似乎没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！</p><p>　　为了解决这个问题，可以将作为返回值的方法保存起来，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// at startup</span><br><span class="hljs-built_in">this</span>.tickFunc = (<br>    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">self</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>         self.tick();<br>      &#125;;<br>    &#125;<br>)(<span class="hljs-built_in">this</span>);<br><span class="hljs-comment">// in the tick() function</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-built_in">this</span>.tickFunc, <span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>　　相比于每次都新建一个方法对象，这种方式在每一帧当中重用了相同的方法对象。这种方式的优势是显而易见的，而这种思想也可以应用在任何以方法为返回值或者在运行时创建方法的情况当中。</p><p><strong>4、高级技术</strong></p><p>　　从根本上来说，javascript本身就是围绕着垃圾收集来设计的。随着我们工作的进行，避免内存垃圾变得越来越困难。因为很多方便实用的Javascript库方法也会产生一些新的对象。对于这些库方法产生的垃圾，我们束手无策，只能重新翻看文档，并且检查方法的返回值。例如，数组的slice方法返回一个新的数组（在不修改原数组的基础上，截取出一部分作为新数组），字符串的substr方法返回一个新的字符串（在不修改原字符串的基础上，截取出一部分字符串作为返回值）等等。</p><p>　　调用这些库方法，将会创建内存垃圾，而你能做的，只有避免调用这些方法，或者用不创建系统垃圾的方式重写这些方法（有点极端啦~）。</p><p>　　例如，在Construct 2引擎中，从数组中利用下标来删除一个元素，是经常进行的操作。最初我们是用下面这种方式来实现的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sliced = arr.slice(index + <span class="hljs-number">1</span>);<br>arr.length = index;<br>arr.push.apply(arr, sliced);<br></code></pre></td></tr></table></figure><p>　　然而，slice方法会返回一个新的数组对象（数组中的元素是原数组中删掉的部分），并且会通过arr.push.apply方法将元素重新复制回原数组，但是在此操作之后，该数组就成为了一片内存垃圾。由于这是我们引擎中的垃圾产生的热点代码（使用频率非常很高），因此我们利用了迭代的方式重写了上述代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = index, len = arr.length – <span class="hljs-number">1</span>; i &lt; len; i++)<br>    arr[i] = arr[i + <span class="hljs-number">1</span>];<br>arr.length = len;<br></code></pre></td></tr></table></figure><p>　　显然，重写大量的库函数是非常痛苦的，因此你必须仔细权衡方法的易用性和内存垃圾产生情况。如果产生大量内存垃圾的方法在动画的每一帧中被多次调用，你可能就会兴高采烈的重写库函数啦。</p><p>　　在递归函数中，通过{}构造空对象，并在递归过程中传递数据，虽然是很方便的。但是更好的方式是：利用一个单独的数组对象作为堆栈，在递归过程中对数组进行push和pop操作。更进一步，不要调用array的pop方法（pop将会使得array的最后一个元素将会变成内存垃圾），而应该使用一个索引来记录数组的最后一个元素的位置，在pop时简单的将索引减一即可；类似的，将索引加1来代替array的push操作，只有当索引对应的元素不存在时，才执行真正的push为数组加入一个新元素。</p><p>　　另外，在任何时候，都应该避免使用向量对象（例如：包含x和y属性的vector2对象）。有些方法将向量对象作为方法返回值，既可以支持返回值的再次修改，又能够将需要的属性一次性返回，使用起来非常方便。但是有时候在一帧动画中，创建了成百上千个这样的向量对象，从而导致严重的垃圾回收性能问题，也是非常常见的。因此最好将这些方法分离成具有独立职责的功能个体，例如：利用getX()和getY()方法（返回具体数据）代替getPosition()方法（返回一个vector2对象）。</p><p><strong>四、总结</strong></p><p>　　在Javascript中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。</p><p>　　但是，为了减少内存垃圾，我们还是可以对javascript代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。</p><p>　　我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的javascript应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。</p><p>转载自：<a href="https://www.cnblogs.com/wp-js/p/7609534.html">javascript的垃圾回收机制 - 最爱小vue - 博客园</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prototype、getPrototypeOf和_proto_之间的不同</title>
    <link href="/2022/01/25/prototype%E3%80%81getPrototypeOf%E5%92%8C_proto_%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
    <url>/2022/01/25/prototype%E3%80%81getPrototypeOf%E5%92%8C_proto_%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="prototype、getPrototypeOf和-proto-之间的不同"><a href="#prototype、getPrototypeOf和-proto-之间的不同" class="headerlink" title="# prototype、getPrototypeOf和_proto_之间的不同"></a># prototype、getPrototypeOf和_proto_之间的不同</h3><p>在学习JavaScript的过程中，原型是如何也绕不过去的一个知识点。虽然现在ES6已经非常普及，许多js的程序员都已经不再用原型的知识点来编写代码了，但是充分的理解原型也是很有必要的，尤其是在阅读他人优秀的js代码时，理解原型能帮助我们更好的理解早期代码。而原型包括三个访问器，这三个访问器有时功能重叠，所以准确的理解并区分他们还是很有必要的。</p><p>这三个访问器就是<code>prototype</code>、<code>getPrototypeOf</code>和<code>__proto__</code>，从名字上可见这三个访问器都是对prototype这个单词做了一些变化，生成这样的属性方法名。为了测试这三个方法的输出，我们先来模拟创建一个存储用户数据User的类。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, passwordHash</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.passwordHash = passwordHash;<br>&#125;<br><br>User.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[User &#x27;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;]&#x27;</span>;<br>&#125;<br><br>User.prototype.checkPassword = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">password</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> hash(password) === <span class="hljs-built_in">this</span>.passwordHash;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们创建的这个User类的构造函数，接收两个参数，一个是用户名name，一个是密码的hash值，并且类中有两个方法<code>toString</code>以及<code>checkPassword</code>用来输出用户信息和检查密码。</p><p>如果这个时候我们打印这三个原型方法的日志会得到一样的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;Lix&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(u)); <span class="hljs-comment">// User &#123; toString: [Function], checkPassword: [Function] &#125;</span><br><br><span class="hljs-built_in">console</span>.log(u.__proto__); <span class="hljs-comment">// User &#123; toString: [Function], checkPassword: [Function] &#125;</span><br><br><span class="hljs-built_in">console</span>.log(User.prototype); <span class="hljs-comment">// User &#123; toString: [Function], checkPassword: [Function] &#125;</span><br></code></pre></td></tr></table></figure><p>既然他们的输出都一样，那么他们是否作用一样呢，我们可以来比较测试一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.getPrototypeOf(u) === User.prototype; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">u.__proto__ === User.prototype; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>既然这两个方法都跟我们User对象的原型相等，那么这三个属性的区别究竟是什么呢？别急，接下来就把结论告诉大家。</p><ul><li><code>C.prototype</code>用于建立由 <code>new C()</code> 创建的对象的原型。</li><li><code>Object.getPrototype(obj)</code>是ES5中用来获取obj对象的原型对象的标准方法。</li><li><code>obj.__proto__</code>是获取obj对象的原型对象的非标准方法。</li></ul><p>所以一般我们是不会直接访问<code>C.prototype</code>去获取原型对象的，在ES5的环境中，我们使用<code>Object.getPrototype(obj)</code>来获取原型对象，而在不支持ES5的环境中，我们可以考虑用<code>__proto__</code>这样的非标准方法来当做权宜之计，希望各位不明白的同学能牢记这些区别。</p>]]></content>
    
    
    
    <tags>
      
      <tag>prototype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>process.nextTick 与 setTimeout的优先级</title>
    <link href="/2022/01/24/process.nextTick%20%E4%B8%8E%20setTimeout%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2022/01/24/process.nextTick%20%E4%B8%8E%20setTimeout%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="process-nextTick-与-setTimeout的优先级"><a href="#process-nextTick-与-setTimeout的优先级" class="headerlink" title="process.nextTick 与 setTimeout的优先级"></a>process.nextTick 与 setTimeout的优先级</h3><p>请看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-comment">//主进程 执行 </span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>)   <span class="hljs-comment">//因为setTimeout是宏任务，所以加入宏任务队列1，[&#x27;2&#x27;]</span><br>   process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-comment">//因为 process.nextTick是微任务，所以加入微任务队列2，[&#x27;4&#x27;,&#x27;3&#x27;]</span><br>  &#125;)<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>) <span class="hljs-comment">//因为此处代码执行不属于异步，所以直接推入主程序执行，[&#x27;4&#x27;]</span><br>      resolve()<br>  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>) <span class="hljs-comment">// 因为promise then 是微任务，所以推入微任务队列2,[&#x27;4&#x27;,&#x27;3&#x27;,&#x27;5&#x27;]</span><br>  &#125;)<br>&#125;,<span class="hljs-number">0</span>)<br><span class="hljs-comment">// process.nextTick总是发生在所有异步任务之前</span><br>process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>)  <span class="hljs-comment">//因为process.nextTick是微任务，所以推入微任务队列1,[&#x27;6&#x27;]</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>)<span class="hljs-comment">//因为此处代码执行不属于异步，所以直接推入主程序执行，[&#x27;6&#x27;,&#x27;7&#x27;]</span><br>    resolve()<br>  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)<span class="hljs-comment">//因为 promise then 是微任务，所以推入微任务队列1,[&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;]</span><br>  &#125;)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>)<span class="hljs-comment">//因为setTimeout是宏任务，所以推入宏任务队列2 ，[&#x27;9&#x27;]</span><br>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>)<span class="hljs-comment">//因为process.nextTick是微任务，所以推入微任务队列3，[&#x27;9&#x27;,&#x27;11&#x27;,&#x27;12&#x27;,&#x27;10&#x27;]</span><br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>)<span class="hljs-comment">//因为此处代码执行不属于异步，所以直接推入主程序执行,[&#x27;9&#x27;,&#x27;11&#x27;]</span><br>      resolve()<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;12&#x27;</span>)<span class="hljs-comment">////因为此处代码执行不属于异步，所以直接推入主程序执行,[&#x27;9&#x27;,&#x27;11&#x27;,&#x27;12&#x27;]</span><br>    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;13&#x27;</span>)<span class="hljs-comment">//因为 promise then 是微任务，所以推入微任务队列3,[&#x27;9&#x27;,&#x27;11&#x27;,&#x27;12&#x27;,&#x27;10&#x27;,&#x27;12&#x27;]</span><br>    &#125;)<br>  &#125;,<span class="hljs-number">0</span>)<br>&#125;)<br><br><span class="hljs-comment">//打印输出</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 6</span><br><span class="hljs-comment">// 7</span><br><span class="hljs-comment">// 8</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 4</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 9</span><br><span class="hljs-comment">// 11</span><br><span class="hljs-comment">// 12</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><p>得出结论：微任务优先级大小：process.nextTick &gt; setTimeout</p>]]></content>
    
    
    
    <tags>
      
      <tag>setTimeout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS类选择器的小细节</title>
    <link href="/2022/01/18/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <url>/2022/01/18/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS类选择器的小细节"><a href="#CSS类选择器的小细节" class="headerlink" title="CSS类选择器的小细节"></a>CSS类选择器的小细节</h3><p><strong>1、我们看一个示例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br>.<span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，无效的类选择器 <code>..special</code> 规则将被忽略，而 <code>h1</code> 仍会设置样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>, .<span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，上述例子所示，当组合在一起时， <code>h1</code> 由于整个规则被认为是无效的，因此和类都不会被设置样式，即这整个代码块都是无效的。</p><p><strong>2、属性选择器</strong></p><p>属性选择器选择器提供了基于元素上某个属性的存在来选择元素的不同方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p><strong>或者甚至根据具有特定值的属性的存在进行选择：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;https://example.com&quot;</span>]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p><strong>3、伪类和伪元素</strong></p><p>伪类，例如，<code>:hover</code>伪类仅在鼠标指针悬停时选择元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>伪元素选择元素的某个部分而不是元素本身。例如，<code>::first-line</code>始终选择元素内的第一行文本</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue;<br> &#125;<br></code></pre></td></tr></table></figure><p>此时p标签的第一行文字为蓝色，其他部分颜色默认。</p><p><strong>4、::first-of-type</strong></p><p> <code>first-of-type</code> 表示一组兄弟元素中其类型的第一个元素。</p><p>例如HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-of-type &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-style</span>: italic;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/img/css-first.jpg" alt="result"></p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object的Create()方法</title>
    <link href="/2022/01/17/Object%E7%9A%84Create()%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/17/Object%E7%9A%84Create()%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="Object的Create-方法"><a href="#Object的Create-方法" class="headerlink" title="Object的Create()方法"></a>Object的Create()方法</h3><p>from MDN</p><blockquote><p>此方法创建一个新对象，使用现有的对象来提供新创建的对象的_proto_</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">isHuman</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">printIntroduction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>. Am I human? <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.isHuman&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> me = <span class="hljs-built_in">Object</span>.create(person);<br><br>me.name = <span class="hljs-string">&#x27;Matthew&#x27;</span>; <span class="hljs-comment">// &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;</span><br>me.isHuman = <span class="hljs-literal">true</span>; <span class="hljs-comment">// inherited properties can be overwritten</span><br><br>me.printIntroduction();<br><span class="hljs-comment">// expected output: &quot;My name is Matthew. Am I human? true&quot;</span><br><br></code></pre></td></tr></table></figure><p>用 <code>Object.create</code>实现类式继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Shape - 父类(superclass)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">this</span>.y = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 父类的方法</span><br>Shape.prototype.move = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x += x;<br>  <span class="hljs-built_in">this</span>.y += y;<br>  <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;Shape moved.&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// Rectangle - 子类(subclass)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"></span>) </span>&#123;<br>  Shape.call(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// call super constructor.</span><br>&#125;<br><br><span class="hljs-comment">// 子类续承父类</span><br>Rectangle.prototype = <span class="hljs-built_in">Object</span>.create(Shape.prototype);<br>Rectangle.prototype.constructor = Rectangle;<br><br><span class="hljs-keyword">var</span> rect = <span class="hljs-keyword">new</span> Rectangle();<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Is rect an instance of Rectangle?&#x27;</span>,<br>  rect <span class="hljs-keyword">instanceof</span> Rectangle); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Is rect an instance of Shape?&#x27;</span>,<br>  rect <span class="hljs-keyword">instanceof</span> Shape); <span class="hljs-comment">// true</span><br>rect.move(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Outputs, &#x27;Shape moved.&#x27;</span><br></code></pre></td></tr></table></figure><p>如果希望能继承到多个对象，则可以使用混入的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>) </span>&#123;<br>     SuperClass.call(<span class="hljs-built_in">this</span>);<br>     OtherSuperClass.call(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 继承一个类</span><br>MyClass.prototype = <span class="hljs-built_in">Object</span>.create(SuperClass.prototype);<br><span class="hljs-comment">// 混合其它</span><br><span class="hljs-built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);<br><span class="hljs-comment">// 重新指定constructor</span><br>MyClass.prototype.constructor = MyClass;<br><br>MyClass.prototype.myMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-comment">// do a thing</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 会把 <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。Object.assign 是在 ES2015 引入的，且可用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#polyfill">polyfilled</a>。要支持旧浏览器的话，可用使用 <a href="https://api.jquery.com/jQuery.extend/">jQuery.extend()</a> 或者 <a href="https://lodash.com/docs/#assign">_.assign()</a>。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>querySelector与getElementById的区别</title>
    <link href="/2022/01/15/querySelector%E4%B8%8EgetElementById%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/15/querySelector%E4%B8%8EgetElementById%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="querySelector与getElementById的区别"><a href="#querySelector与getElementById的区别" class="headerlink" title="querySelector与getElementById的区别"></a>querySelector与getElementById的区别</h3><p>今天学习过程中，发现了一种获取dom元素时，我不经常使用的document.querySelector方法，乍一看querySelector还以为是jquery中的方法，谁让他们的名字都有个query。那么querySelector 和 getElementById究竟有什么区别？</p><p>查阅文档：</p><blockquote><ol><li>querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。<br>注意： querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。<br>querySelectorAll() 方法返回文档中匹配指定 CSS 选择器的所有元素，返回 [NodeList] 对象。<br>2.[document.getElementsByClassName()]： 返回文档中所有指定类名的元素集合，作为 NodeList 对象。<br>[document.getElementById()]：返回对拥有指定 id 的第一个对象的引用。<br>[document.getElementsByName()]：返回带有指定名称的对象集合。<br>[document.getElementsByTagName()]：返回带有指定标签名的对象集合。</li></ol></blockquote><p>看似还是找不到区别，好在万能的搜索引擎告诉了我答案</p><p><strong>query选择符选出来的元素及元素数组是静态的，而getElement这种方法选出的元素是动态的。</strong></p><p>看一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;aa&quot;</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> querySelector = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#test&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-keyword">var</span> getElementById = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(querySelector === getElementById) <span class="hljs-comment">// true</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> querySelectorAll = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;p&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i &lt; querySelectorAll.length;i++)&#123;</span><br><span class="javascript">        querySelector.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>))</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(querySelectorAll.length) <span class="hljs-comment">//值为2,动态添加元素并没有使querySelectorAll发生变化</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> getElementsByTagName = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;p&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++)&#123;</span><br><span class="javascript">        getElementById.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>))</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(getElementsByTagName.length) <span class="hljs-comment">//值为4+3=7,每次动态添加元素都使getElementsByTagName发生了变化</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：由于querySelector是按照CSS规范来实现的，所以它传入的字符串第一个字符不能是数字。</p><p>再看一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-comment">//获取到ul，为了之后动态的添加li</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box&#x27;</span>);</span><br><span class="javascript"><span class="hljs-comment">//获取到现有ul里面的li</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> list = ul.getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>);</span><br><span class="javascript">     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="javascript">        ul.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>)); <span class="hljs-comment">//动态追加li</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码会陷入死循环，注意for中的循环条件list.length，在第一次获取到里面的3个li后，每当往ul里添加了新元素后，list便会更新其值，重新获取ul里的所有li。也就是getElement(s)Byxxxx获取的是动态集合，它总会随着dom结构的变化而变化。即每一次调用list都会重新对文档进行查询，导致无限循环的问题。</p><p>修改：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-comment">//获取到ul，为了之后动态的添加li</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box&#x27;</span>);</span><br><span class="javascript"><span class="hljs-comment">//获取到现有ul里面的li</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> list = ul.getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>);</span><br><span class="javascript">     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;</span><br><span class="javascript">        ul.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>)); <span class="hljs-comment">//动态追加li</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(list.length); <span class="hljs-comment">//7</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将for循环条件修改后，新在ul里添加了4个元素，所有现在打印出来的长度为7。</p><p>修改2：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>测试3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-comment">//获取到ul，为了之后动态的添加li</span></span><br><span class="javascript">     <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);</span><br><span class="javascript"><span class="hljs-comment">//获取到现有ul里面的所有li</span></span><br><span class="javascript">     <span class="hljs-keyword">var</span> list = ul.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>);</span><br><span class="javascript">     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="javascript">         ul.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>));<span class="hljs-comment">//动态追加li</span></span><br><span class="javascript">     &#125;</span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(list.length); <span class="hljs-comment">//输出的结果仍然是3，不是此时li的数量6</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码静态集合体现在.querySelectorAll(‘li’)获取到ul里所有li后，不管后续再动态添加了多少li，都不会对其参数影响。</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章回顾TypeScript基本用法</title>
    <link href="/2022/01/11/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%9B%9E%E9%A1%BETypeScript%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2022/01/11/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%9B%9E%E9%A1%BETypeScript%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一篇文章回顾TypeScript基本用法"><a href="#一篇文章回顾TypeScript基本用法" class="headerlink" title="一篇文章回顾TypeScript基本用法"></a>一篇文章回顾TypeScript基本用法</h3><p>TypeScript 是一门为开发大型 JavaScript 应用而设计的语言。TypeScript 在 JavaScript 的基础上增加了类、模块、接口、泛型和静态类型等常见的概念。它是 JavaScript 的超集：所有 JavaScript 代码都是有效的 TypeScript 代码，因此任何 JavaScript 项目都可以无缝引入 TypeScript，TypeScript 编译器最终会把 TypeScript 代码编译成 JavaScript 代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// TypeScript 有三种基本类型，布尔类型、数值类型、字符串类型</span><br><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> lines: <span class="hljs-built_in">number</span> = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">let</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Anders&#x27;</span>;<br><br><span class="hljs-comment">// 如果不知道是什么类型，可以使用 &quot;any&quot; (任意)类型</span><br><span class="hljs-keyword">let</span> notSure: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;<br>notSure = <span class="hljs-string">&#x27;可以重新赋值，转换为字符串类型&#x27;</span>;<br>notSure = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 亦可，重新定义为布尔类型</span><br><br><span class="hljs-comment">// 使用 const 关键字将一个字面量修饰为常量</span><br><span class="hljs-keyword">const</span> numLivesForCat = <span class="hljs-number">9</span>;<br>numLivesForCat = <span class="hljs-number">1</span>; <span class="hljs-comment">// 常量不能重新被赋值，所以这里会报错</span><br><br><span class="hljs-comment">// TypeScript 中的 collection 有两种表示形式, 一种是有类型的数组，另一种是泛型数组</span><br><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// 或者，使用泛型数组</span><br><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// 枚举：</span><br><span class="hljs-built_in">enum</span> Color &#123;Red, Green, Blue&#125;<br><span class="hljs-keyword">let</span> c: Color = Color.Green;<br><br><span class="hljs-comment">// 最后是 &quot;void&quot;，它用于表明函数没有任何返回值的特殊情况</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bigHorribleAlert</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>  alert(<span class="hljs-string">&#x27;我是个烦人的弹出框！&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 函数是&quot;一等公民&quot;(first class citizens), 支持使用 lambda 胖箭头表达式和类型推断</span><br><br><span class="hljs-comment">// 以下 f1-f5 五个函数是等价的，TypeScript 编译器会把它们编译成相同的 JavaScript 代码(可以到 Playground 验证)</span><br><span class="hljs-comment">// 一般的函数</span><br><span class="hljs-keyword">let</span> f1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123; <span class="hljs-keyword">return</span> i * i; &#125;;<br><span class="hljs-comment">// 根据返回值推断函数返回类型</span><br><span class="hljs-keyword">let</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i: <span class="hljs-built_in">number</span></span>) </span>&#123; <span class="hljs-keyword">return</span> i * i; &#125;;<br><span class="hljs-comment">// 胖箭头表达式</span><br><span class="hljs-keyword">let</span> f3 = (i: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> &#123; <span class="hljs-keyword">return</span> i * i; &#125;;<br><span class="hljs-comment">// 根据返回值推断返回类型的胖箭头表达式</span><br><span class="hljs-keyword">let</span> f4 = <span class="hljs-function">(<span class="hljs-params">i: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> i * i; &#125;;<br><span class="hljs-comment">// 根据返回值推断返回类型的胖箭头表达式, 省略花括号的同时，可以同时省去 return 关键字</span><br><span class="hljs-keyword">let</span> f5 = <span class="hljs-function">(<span class="hljs-params">i: <span class="hljs-built_in">number</span></span>) =&gt;</span>  i * i;<br><br><span class="hljs-comment">// 接口是结构化的，任何具备接口中声明的全部属性的对象，都与该接口兼容</span><br><span class="hljs-keyword">interface</span> Person &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// 使用 &quot;?&quot; 标识，表明该属性是一个非必需属性</span><br>  age?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 函数</span><br>  move(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现 &quot;Person&quot; 接口的对象，当它具备 &quot;name&quot; 属性和 &quot;move&quot; 方法之后可被视为一个 &quot;Person&quot;</span><br><span class="hljs-keyword">let</span> p: Person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bobby&#x27;</span>, <span class="hljs-attr">move</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125;;<br><span class="hljs-comment">// 带可选属性的对象</span><br><span class="hljs-keyword">let</span> validPerson: Person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bobby&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">move</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125;;<br><span class="hljs-comment">// 由于该对象 &quot;age&quot; 属性的类型不是 &quot;number&quot; ，所以这不是一个 &quot;Person&quot;</span><br><span class="hljs-keyword">let</span> invalidPerson: Person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bobby&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-literal">true</span> &#125;;<br><br><span class="hljs-comment">// 接口同样可以描述一个函数的类型</span><br><span class="hljs-keyword">interface</span> SearchFunc &#123;<br>  (source: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-comment">// 参数名并不重要，参数类型才是最重要的</span><br><span class="hljs-keyword">let</span> mySearch: SearchFunc;<br>mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src: <span class="hljs-built_in">string</span>, sub: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> src.search(sub) !== -<span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 类 - 成员访问权限默认都是公共的 (public)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-comment">// 成员属性</span><br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-comment">// 构造器 - 在构造器中使用 public/private 关键字修饰的变量，会被声明为类的成员属性。</span><br>  <span class="hljs-comment">// 下面这个例子中，y 会像 x 一样被声明定义为类成员属性，而不再需要额外代码</span><br>  <span class="hljs-comment">// 声明时，同样支持指定默认值</span><br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, <span class="hljs-keyword">public</span> y: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.x = x;<br>  &#125;<br><br>  <span class="hljs-comment">// 成员函数</span><br>  <span class="hljs-function"><span class="hljs-title">dist</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-built_in">this</span>.x * <span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y * <span class="hljs-built_in">this</span>.y); &#125;<br><br>  <span class="hljs-comment">// 静态成员</span><br>  <span class="hljs-keyword">static</span> origin = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">10</span> , <span class="hljs-number">20</span>);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">25</span>); <span class="hljs-comment">// y 为构造器中指定的默认值：0</span><br><br><span class="hljs-comment">// 继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point3D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, <span class="hljs-keyword">public</span> z: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">// 必须显式调用父类的构造器</span><br>  &#125;<br><br>  <span class="hljs-comment">// 重写父类中的 dist() 函数</span><br>  <span class="hljs-function"><span class="hljs-title">dist</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">super</span>.dist();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(d * d + <span class="hljs-built_in">this</span>.z * <span class="hljs-built_in">this</span>.z);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 模块, &quot;.&quot; 符号可以作为子模块的分隔符</span><br><span class="hljs-built_in">module</span> Geometry &#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> sideLength: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">area</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(<span class="hljs-built_in">this</span>.sideLength, <span class="hljs-number">2</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-keyword">new</span> Geometry.Square(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 为模块创建一个本地别名</span><br><span class="hljs-keyword">import</span> G = Geometry;<br><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-keyword">new</span> G.Square(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 泛型</span><br><span class="hljs-comment">// 类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tuple</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> item1: T1, <span class="hljs-keyword">public</span> item2: T2</span>)</span> &#123;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">interface</span> Pair&lt;T&gt; &#123;<br>  <span class="hljs-attr">item1</span>: T;<br>  item2: T;<br>&#125;<br><br><span class="hljs-comment">// 以及函数</span><br><span class="hljs-keyword">let</span> pairToTuple = <span class="hljs-function"><span class="hljs-keyword">function</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">p: Pair&lt;T&gt;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Tuple(p.item1, p.item2);<br>&#125;;<br><br><span class="hljs-keyword">let</span> tuple = pairToTuple(&#123; <span class="hljs-attr">item1</span>: <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-attr">item2</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;);<br><br><span class="hljs-comment">// 引用定义文件</span><br><span class="hljs-comment">/// &lt;reference path=&quot;jquery.d.ts&quot; /&gt;</span><br><br><span class="hljs-comment">// 模板字符串(使用反引号的字符串)</span><br><span class="hljs-comment">// 嵌入变量的模板字符串</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Tyrone&#x27;</span>;<br><span class="hljs-keyword">let</span> greeting = <span class="hljs-string">`Hi <span class="hljs-subst">$&#123;name&#125;</span>, how are you?`</span>;<br><span class="hljs-comment">// 有多行内容的模板字符串</span><br><span class="hljs-keyword">let</span> multiline = <span class="hljs-string">`This is an example</span><br><span class="hljs-string">of a multiline string`</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新建文件夹——搭建前端UI组件库</title>
    <link href="/2022/01/10/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AFUI%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    <url>/2022/01/10/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AFUI%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="新建文件夹——搭建前端UI组件库"><a href="#新建文件夹——搭建前端UI组件库" class="headerlink" title="新建文件夹——搭建前端UI组件库"></a>新建文件夹——搭建前端UI组件库</h3><p>目前市面上有很多功能强大且完善的组件库供我们使用，比如基于React的antd，material（个人更喜欢这个），基于Vue的elementUI、iView等。</p><p>为啥我们想做一个自己的组件库呢？有大佬给出的观点如下：</p><blockquote><p>我们使用第三方组件库搭建一个企业级应用是完全没有问题的，但是另一方面，随着我们对用户体验以及网站性能的要求越来越高，流量及金钱，速度即王道，对于专注于做C端的企业来说，尽可能的减少用户等待才能留住更多的用户，比如我们在某宝，某东上买一个商品，结果我们花了一分钟商品列表还没有出来（形容的有点夸张），这种情况下客户可有可能直接选择某拼了。很明显像ant-design和elementUI这样的组件不适合做C端产品，因为体积太大了，除非用高性能服务器或者其他方式弥补。</p></blockquote><p>嗯，虽然我们目前还不会接触到这样大规模的商城页面开发，但要面向未来嘛，另外通过做组件库，也能学到不少东西（吧）</p><p>我喜欢前端，其实说到底，喜欢的是设计，是界面，所以做组件库，真是到我心坎里了w</p><p>搞一个属于自己风格的组件库，想想就刺激</p><p>开个头吧，已经真 · 新建文件夹了 ↓</p><p><img src="/img/aemonUI.jpg" alt="我是图片"></p><p>哈哈哈哈，话不多说，冲~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>UI component</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello,zyc</title>
    <link href="/2022/01/09/hello-zyc/"/>
    <url>/2022/01/09/hello-zyc/</url>
    
    <content type="html"><![CDATA[<p>This is my first article in hexo !<br>Hello, nice to meet you, I am zyc.</p><h2 id="and-I-want-to-have-a-try"><a href="#and-I-want-to-have-a-try" class="headerlink" title="and I want to have a try"></a>and I want to have a try</h2><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>About me: <a href="https://github.com/lovesatoriforever">Github</a></p><h2 id="Have-fun"><a href="#Have-fun" class="headerlink" title="Have fun!"></a>Have fun!</h2>]]></content>
    
    
    
    <tags>
      
      <tag>first</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/01/09/hello-world/"/>
    <url>/2022/01/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
